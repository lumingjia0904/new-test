<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for lib/blueBrid/blueBrid.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
<body>
<div class='wrapper'>
  <div class='pad1'>
    <h1>
      <a href="../../index.html">All files</a> / <a href="index.html">lib/blueBrid</a> blueBrid.js
    </h1>
    <div class='clearfix'>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Statements</span>
        <span class='fraction'>0/1761</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Branches</span>
        <span class='fraction'>0/1291</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Functions</span>
        <span class='fraction'>0/593</span>
      </div>
      <div class='fl pad1y space-right2'>
        <span class="strong">0% </span>
        <span class="quiet">Lines</span>
        <span class='fraction'>0/3</span>
      </div>
    </div>
  </div>
  <div class='status-line low'></div>
<pre><table class="coverage">
<tr><td class="line-count quiet">1
2
3</td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("object"==typeof exports&amp;&amp;"undefined"!=typeof module)<span class="cstat-no" title="statement not covered" >module.exports=t();else <span class="cstat-no" title="statement not covered" >if("function"==typeof define&amp;&amp;define.amd)<span class="cstat-no" title="statement not covered" >define([],t);else{var e;<span class="cstat-no" title="statement not covered" >"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&amp;&amp;(e=self),e.Promise=t()}}</span>(<span class="fstat-no" title="function not covered" ></span></span>function()</span>{<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >r(t,e,n){function <span class="fstat-no" title="function not covered" >i(s,a){<span class="cstat-no" title="statement not covered" >if(!e[s]){<span class="cstat-no" title="statement not covered" >if(!t[s]){var c=<span class="cstat-no" title="statement not covered" >"function"==typeof _dereq_&amp;&amp;_dereq_;<span class="cstat-no" title="statement not covered" >if(!a&amp;&amp;c)<span class="cstat-no" title="statement not covered" >return c(s,!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(o)<span class="cstat-no" title="statement not covered" >return o(s,!0);v</span></span>ar l=<span class="cstat-no" title="statement not covered" >new Error("Cannot find module '"+s+"'");<span class="cstat-no" title="statement not covered" >throw l.code="MODULE_NOT_FOUND",l}v</span></span>ar u=<span class="cstat-no" title="statement not covered" >e[s]={exports:{}};<span class="cstat-no" title="statement not covered" >t[s][0].call(u.exports,<span class="fstat-no" title="function not covered" >function(</span>e){var n=<span class="cstat-no" title="statement not covered" >t[s][1][e];<span class="cstat-no" title="statement not covered" >return i(n?n:e)},</span>u,u.exports,r,t,e,n)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn e[s].exports}<span class="cstat-no" title="statement not covered" >f</span>or(var o="function"==typeof _dereq_&amp;&amp;_dereq_,s=0;s&lt;n.length;s++)<span class="cstat-no" title="statement not covered" >i(n[s]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}(</span>{1:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t){function <span class="fstat-no" title="function not covered" >e(t){var e=<span class="cstat-no" title="statement not covered" >new n(t),r=<span class="cstat-no" title="statement not covered" >e.promise();<span class="cstat-no" title="statement not covered" >return e.setHowMany(1),e.setUnwrap(),e.init(),r}v</span>ar n=<span class="cstat-no" title="statement not covered" >t._SomePromiseArray;<span class="cstat-no" title="statement not covered" >t.any=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return e(t)},</span>t.prototype.any=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return e(this)}}</span>}</span>,</span>{}],2:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";function <span class="fstat-no" title="function not covered" >r(){<span class="cstat-no" title="statement not covered" >this._customScheduler=!1,this._isTickUsed=!1,this._lateQueue=new u(16),this._normalQueue=new u(16),this._haveDrainedQueues=!1,this._trampolineEnabled=!0;v</span>ar t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" >this.drainQueues=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t._drainQueues()},</span>this._schedule=l}f</span>unction <span class="fstat-no" title="function not covered" >i(t,e,n){<span class="cstat-no" title="statement not covered" >this._lateQueue.push(t,e,n),this._queueTick()}f</span>unction <span class="fstat-no" title="function not covered" >o(t,e,n){<span class="cstat-no" title="statement not covered" >this._normalQueue.push(t,e,n),this._queueTick()}f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >this._normalQueue._pushOne(t),this._queueTick()}v</span>ar a;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >throw new Error}c</span>atch(c){<span class="cstat-no" title="statement not covered" >a=c}v</span></span>ar l=<span class="cstat-no" title="statement not covered" >t("./schedule"),u=<span class="cstat-no" title="statement not covered" >t("./queue"),p=<span class="cstat-no" title="statement not covered" >t("./util");<span class="cstat-no" title="statement not covered" >r.prototype.setScheduler=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this._schedule;<span class="cstat-no" title="statement not covered" >return this._schedule=t,this._customScheduler=!0,e},</span>r.prototype.hasCustomScheduler=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._customScheduler},</span>r.prototype.enableTrampoline=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._trampolineEnabled=!0},</span>r.prototype.disableTrampolineIfNecessary=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >p.hasDevTools&amp;&amp;(this._trampolineEnabled=!1)},</span>r.prototype.haveItemsQueued=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._isTickUsed||this._haveDrainedQueues},</span>r.prototype.fatalError=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >e?(process.stderr.write("Fatal "+(t instanceof Error?t.stack:t)+"\n"),process.exit(2)):this.throwLater(t)},</span>r.prototype.throwLater=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if(1===arguments.length&amp;&amp;(e=t,t=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >throw e})</span>,"undefined"!=typeof setTimeout)<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t(e)},</span>0);else <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this._schedule(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t(e)})</span>}c</span>atch(n){<span class="cstat-no" title="statement not covered" >throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")}}</span>,</span></span>p.hasDevTools?(r.prototype.invokeLater=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >this._trampolineEnabled?i.call(this,t,e,n):this._schedule(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t.call(e,n)},</span>100)})</span>},</span>r.prototype.invoke=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >this._trampolineEnabled?o.call(this,t,e,n):this._schedule(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t.call(e,n)})</span>},</span>r.prototype.settlePromises=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._trampolineEnabled?s.call(this,t):this._schedule(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t._settlePromises()})</span>})</span>:(r.prototype.invokeLater=i,r.prototype.invoke=o,r.prototype.settlePromises=s),r.prototype._drainQueue=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >for(;t.length()&gt;0;){var e=<span class="cstat-no" title="statement not covered" >t.shift();<span class="cstat-no" title="statement not covered" >if("function"==typeof e){var n=<span class="cstat-no" title="statement not covered" >t.shift(),r=<span class="cstat-no" title="statement not covered" >t.shift();<span class="cstat-no" title="statement not covered" >e.call(n,r)}e</span>lse <span class="cstat-no" title="statement not covered" >e._settlePromises()}}</span></span>,</span>r.prototype._drainQueues=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._drainQueue(this._normalQueue),this._reset(),this._haveDrainedQueues=!0,this._drainQueue(this._lateQueue)},</span>r.prototype._queueTick=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._isTickUsed||(this._isTickUsed=!0,this._schedule(this.drainQueues))},</span>r.prototype._reset=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._isTickUsed=!1},</span>e.exports=r,e.exports.firstLineError=a},</span>{"./queue":26,"./schedule":29,"./util":36}],3:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,r){var i=<span class="cstat-no" title="statement not covered" >!1,o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >this._reject(e)},</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >e.promiseRejectionQueued=!0,e.bindingPromise._then(o,o,null,this,t)},</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >0===(50397184&amp;this._bitField)&amp;&amp;this._resolveCallback(e.target)},</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >e.promiseRejectionQueued||this._reject(t)};<span class="cstat-no" title="statement not covered" ></span>t.prototype.bind=<span class="fstat-no" title="function not covered" >function(</span>o){<span class="cstat-no" title="statement not covered" >i||(i=!0,t.prototype._propagateFrom=r.propagateFromFunction(),t.prototype._boundValue=r.boundValueFunction());v</span>ar l=<span class="cstat-no" title="statement not covered" >n(o),u=<span class="cstat-no" title="statement not covered" >new t(e);<span class="cstat-no" title="statement not covered" >u._propagateFrom(this,1);v</span>ar p=<span class="cstat-no" title="statement not covered" >this._target();<span class="cstat-no" title="statement not covered" >if(u._setBoundTo(l),l instanceof t){var h=<span class="cstat-no" title="statement not covered" >{promiseRejectionQueued:!1,promise:u,target:p,bindingPromise:l};<span class="cstat-no" title="statement not covered" >p._then(e,s,void 0,u,h),l._then(a,c,void 0,u,h),u._setOnCancel(l)}e</span>lse <span class="cstat-no" title="statement not covered" >u._resolveCallback(p);<span class="cstat-no" title="statement not covered" >r</span></span>eturn u},</span>t.prototype._setBoundTo=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >void 0!==t?(this._bitField=2097152|this._bitField,this._boundTo=t):this._bitField=-2097153&amp;this._bitField},</span>t.prototype._isBound=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 2097152===(2097152&amp;this._bitField)},</span>t.bind=<span class="fstat-no" title="function not covered" >function(</span>e,n){<span class="cstat-no" title="statement not covered" >return t.resolve(n).bind(e)}}</span>}</span>,</span>{}],4:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";function <span class="fstat-no" title="function not covered" >r(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >Promise===o&amp;&amp;(Promise=i)}c</span>atch(t){}<span class="cstat-no" title="statement not covered" >r</span>eturn o}v</span>ar i;<span class="cstat-no" title="statement not covered" >"undefined"!=typeof Promise&amp;&amp;(i=Promise);v</span>ar o=<span class="cstat-no" title="statement not covered" >t("./promise")();<span class="cstat-no" title="statement not covered" >o.noConflict=r,e.exports=o},</span>{"./promise":22}],5:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >Object.create;<span class="cstat-no" title="statement not covered" >if(r){var i=<span class="cstat-no" title="statement not covered" >r(null),o=<span class="cstat-no" title="statement not covered" >r(null);<span class="cstat-no" title="statement not covered" >i[" size"]=o[" size"]=0}<span class="cstat-no" title="statement not covered" >e</span></span>.exports=<span class="fstat-no" title="function not covered" >function(</span>e){function <span class="fstat-no" title="function not covered" >n(t,n){var r;<span class="cstat-no" title="statement not covered" >if(null!=t&amp;&amp;(r=t[n]),"function"!=typeof r){var i=<span class="cstat-no" title="statement not covered" >"Object "+a.classString(t)+" has no method '"+a.toString(n)+"'";<span class="cstat-no" title="statement not covered" >throw new e.TypeError(i)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}f</span>unction <span class="fstat-no" title="function not covered" >r(t){var e=<span class="cstat-no" title="statement not covered" >this.pop(),r=<span class="cstat-no" title="statement not covered" >n(t,e);<span class="cstat-no" title="statement not covered" >return r.apply(t,this)}f</span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >return t[this]}f</span>unction <span class="fstat-no" title="function not covered" >o(t){var e=<span class="cstat-no" title="statement not covered" >+this;<span class="cstat-no" title="statement not covered" >return 0&gt;e&amp;&amp;(e=Math.max(0,e+t.length)),t[e]}v</span>ar s,a=<span class="cstat-no" title="statement not covered" >t("./util"),c=<span class="cstat-no" title="statement not covered" >a.canEvaluate;<span class="cstat-no" title="statement not covered" >a.isIdentifier,e.prototype.call=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,1);<span class="cstat-no" title="statement not covered" >return e.push(t),this._then(r,void 0,void 0,e,void 0)},</span>e.prototype.get=<span class="fstat-no" title="function not covered" >function(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >"number"==typeof t;<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >e=o;else <span class="cstat-no" title="statement not covered" >if(c){var r=<span class="cstat-no" title="statement not covered" >s(t);<span class="cstat-no" title="statement not covered" >e=null!==r?r:i}e</span>lse <span class="cstat-no" title="statement not covered" >e=i;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this._then(e,void 0,void 0,t,void 0)}}</span>}</span>,</span>{"./util":36}],6:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i){var o=<span class="cstat-no" title="statement not covered" >t("./util"),s=<span class="cstat-no" title="statement not covered" >o.tryCatch,a=<span class="cstat-no" title="statement not covered" >o.errorObj,c=<span class="cstat-no" title="statement not covered" >e._async;<span class="cstat-no" title="statement not covered" >e.prototype["break"]=e.prototype.cancel=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(!i.cancellation())<span class="cstat-no" title="statement not covered" >return this._warn("cancellation is disabled");<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=this,e=t;t._isCancellable();){<span class="cstat-no" title="statement not covered" >if(!t._cancelBy(e)){<span class="cstat-no" title="statement not covered" >e._isFollowing()?e._followee().cancel():e._cancelBranched();<span class="cstat-no" title="statement not covered" >b</span>reak}v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t._cancellationParent;<span class="cstat-no" title="statement not covered" >if(null==n||!n._isCancellable()){<span class="cstat-no" title="statement not covered" >t._isFollowing()?t._followee().cancel():t._cancelBranched();<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" >t</span></span>._isFollowing()&amp;&amp;t._followee().cancel(),t._setWillBeCancelled(),e=t,t=n}}</span>,</span>e.prototype._branchHasCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._branchesRemainingToCancel--},</span>e.prototype._enoughBranchesHaveCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return void 0===this._branchesRemainingToCancel||this._branchesRemainingToCancel&lt;=0},</span>e.prototype._cancelBy=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t===this?(this._branchesRemainingToCancel=0,this._invokeOnCancel(),!0):(this._branchHasCancelled(),!!this._enoughBranchesHaveCancelled()&amp;&amp;(this._invokeOnCancel(),!0))},</span>e.prototype._cancelBranched=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._enoughBranchesHaveCancelled()&amp;&amp;this._cancel()},</span>e.prototype._cancel=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._isCancellable()&amp;&amp;(this._setCancelled(),c.invoke(this._cancelPromises,this,void 0))},</span>e.prototype._cancelPromises=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._length()&gt;0&amp;&amp;this._settlePromises()},</span>e.prototype._unsetOnCancel=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._onCancelField=void 0},</span>e.prototype._isCancellable=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this.isPending()&amp;&amp;!this._isCancelled()},</span>e.prototype.isCancellable=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this.isPending()&amp;&amp;!this.isCancelled()},</span>e.prototype._doInvokeOnCancel=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if(o.isArray(t))<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >this._doInvokeOnCancel(t[n],e);else <span class="cstat-no" title="statement not covered" >if(void 0!==t)<span class="cstat-no" title="statement not covered" >if("function"==typeof t){<span class="cstat-no" title="statement not covered" >if(!e){var r=<span class="cstat-no" title="statement not covered" >s(t).call(this._boundValue());<span class="cstat-no" title="statement not covered" >r===a&amp;&amp;(this._attachExtraTrace(r.e),c.throwLater(r.e))}}</span>e</span>lse <span class="cstat-no" title="statement not covered" >t._resultCancelled(this)},</span></span></span></span>e.prototype._invokeOnCancel=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._onCancel();<span class="cstat-no" title="statement not covered" >this._unsetOnCancel(),c.invoke(this._doInvokeOnCancel,this,t)},</span>e.prototype._invokeInternalOnCancel=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._isCancellable()&amp;&amp;(this._doInvokeOnCancel(this._onCancel(),!0),this._unsetOnCancel())},</span>e.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this.cancel()}}</span>}</span>,</span>{"./util":36}],7:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e){function <span class="fstat-no" title="function not covered" >n(t,n,a){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(</span>c){var l=<span class="cstat-no" title="statement not covered" >a._boundValue();<span class="cstat-no" title="statement not covered" >t:<span class="cstat-no" title="statement not covered" >for(var u=0;u&lt;t.length;++u){var p=<span class="cstat-no" title="statement not covered" >t[u];<span class="cstat-no" title="statement not covered" >if(p===Error||null!=p&amp;&amp;p.prototype instanceof Error){<span class="cstat-no" title="statement not covered" >if(c instanceof p)<span class="cstat-no" title="statement not covered" >return o(n).call(l,c)}e</span></span>lse <span class="cstat-no" title="statement not covered" >if("function"==typeof p){var h=<span class="cstat-no" title="statement not covered" >o(p).call(l,c);<span class="cstat-no" title="statement not covered" >if(h===s)<span class="cstat-no" title="statement not covered" >return h;<span class="cstat-no" title="statement not covered" >i</span></span>f(h)<span class="cstat-no" title="statement not covered" >return o(n).call(l,c)}e</span></span>lse <span class="cstat-no" title="statement not covered" >if(r.isObject(c)){<span class="cstat-no" title="statement not covered" >for(var f=i(p),_=0;_&lt;f.length;++_){var d=<span class="cstat-no" title="statement not covered" >f[_];<span class="cstat-no" title="statement not covered" >if(p[d]!=c[d])<span class="cstat-no" title="statement not covered" >continue t}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o(n).call(l,c)}}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span>eturn e}}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >t("./util"),i=<span class="cstat-no" title="statement not covered" >t("./es5").keys,o=<span class="cstat-no" title="statement not covered" >r.tryCatch,s=<span class="cstat-no" title="statement not covered" >r.errorObj;<span class="cstat-no" title="statement not covered" >return n}}</span>,</span>{"./es5":13,"./util":36}],8:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t){function <span class="fstat-no" title="function not covered" >e(){<span class="cstat-no" title="statement not covered" >this._trace=new e.CapturedTrace(r())}f</span>unction <span class="fstat-no" title="function not covered" >n(){<span class="cstat-no" title="statement not covered" >return i?new e:void 0}f</span>unction <span class="fstat-no" title="function not covered" >r(){var t=<span class="cstat-no" title="statement not covered" >o.length-1;<span class="cstat-no" title="statement not covered" >return t&gt;=0?o[t]:void 0}v</span>ar i=<span class="cstat-no" title="statement not covered" >!1,o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" >return t.prototype._promiseCreated=<span class="fstat-no" title="function not covered" >function()</span>{},t.prototype._pushContext=<span class="fstat-no" title="function not covered" >function()</span>{},t.prototype._popContext=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return null},</span>t._peekContext=t.prototype._peekContext=<span class="fstat-no" title="function not covered" >function()</span>{},e.prototype._pushContext=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >void 0!==this._trace&amp;&amp;(this._trace._promiseCreated=null,o.push(this._trace))},</span>e.prototype._popContext=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(void 0!==this._trace){var t=<span class="cstat-no" title="statement not covered" >o.pop(),e=<span class="cstat-no" title="statement not covered" >t._promiseCreated;<span class="cstat-no" title="statement not covered" >return t._promiseCreated=null,e}<span class="cstat-no" title="statement not covered" >r</span></span>eturn null},</span>e.CapturedTrace=null,e.create=n,e.deactivateLongStackTraces=<span class="fstat-no" title="function not covered" >function()</span>{},e.activateLongStackTraces=<span class="fstat-no" title="function not covered" >function()</span>{var n=<span class="cstat-no" title="statement not covered" >t.prototype._pushContext,o=<span class="cstat-no" title="statement not covered" >t.prototype._popContext,s=<span class="cstat-no" title="statement not covered" >t._peekContext,a=<span class="cstat-no" title="statement not covered" >t.prototype._peekContext,c=<span class="cstat-no" title="statement not covered" >t.prototype._promiseCreated;<span class="cstat-no" title="statement not covered" >e.deactivateLongStackTraces=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t.prototype._pushContext=n,t.prototype._popContext=o,t._peekContext=s,t.prototype._peekContext=a,t.prototype._promiseCreated=c,i=!1},</span>i=!0,t.prototype._pushContext=e.prototype._pushContext,t.prototype._popContext=e.prototype._popContext,t._peekContext=t.prototype._peekContext=r,t.prototype._promiseCreated=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._peekContext();<span class="cstat-no" title="statement not covered" >t&amp;&amp;null==t._promiseCreated&amp;&amp;(t._promiseCreated=this)}}</span>,</span>e}}</span>,</span>{}],9:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n){function <span class="fstat-no" title="function not covered" >r(t,e){<span class="cstat-no" title="statement not covered" >return{promise:e}}f</span>unction <span class="fstat-no" title="function not covered" >i(){<span class="cstat-no" title="statement not covered" >return!1}f</span>unction <span class="fstat-no" title="function not covered" >o(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t(e,n,<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new TypeError("onCancel must be a function, got: "+H.toString(t));<span class="cstat-no" title="statement not covered" >r</span></span>._attachCancellationCallback(t)})</span>}c</span>atch(i){<span class="cstat-no" title="statement not covered" >return i}}</span>f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >if(!this._isCancellable())<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this._onCancel();<span class="cstat-no" title="statement not covered" >void 0!==e?H.isArray(e)?e.push(t):this._setOnCancel([e,t]):this._setOnCancel(t)}f</span>unction <span class="fstat-no" title="function not covered" >a(){<span class="cstat-no" title="statement not covered" >return this._onCancelField}f</span>unction <span class="fstat-no" title="function not covered" >c(t){<span class="cstat-no" title="statement not covered" >this._onCancelField=t}f</span>unction <span class="fstat-no" title="function not covered" >l(){<span class="cstat-no" title="statement not covered" >this._cancellationParent=void 0,this._onCancelField=void 0}f</span>unction <span class="fstat-no" title="function not covered" >u(t,e){<span class="cstat-no" title="statement not covered" >if(0!==(1&amp;e)){<span class="cstat-no" title="statement not covered" >this._cancellationParent=t;v</span>ar n=<span class="cstat-no" title="statement not covered" >t._branchesRemainingToCancel;<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=0),t._branchesRemainingToCancel=n+1}<span class="cstat-no" title="statement not covered" >0</span></span>!==(2&amp;e)&amp;&amp;t._isBound()&amp;&amp;this._setBoundTo(t._boundTo)}f</span>unction <span class="fstat-no" title="function not covered" >p(t,e){<span class="cstat-no" title="statement not covered" >0!==(2&amp;e)&amp;&amp;t._isBound()&amp;&amp;this._setBoundTo(t._boundTo)}f</span>unction <span class="fstat-no" title="function not covered" >h(){var t=<span class="cstat-no" title="statement not covered" >this._boundTo;<span class="cstat-no" title="statement not covered" >return void 0!==t&amp;&amp;t instanceof e?t.isFulfilled()?t.value():void 0:t}f</span>unction <span class="fstat-no" title="function not covered" >f(){<span class="cstat-no" title="statement not covered" >this._trace=new S(this._peekContext())}f</span>unction <span class="fstat-no" title="function not covered" >_(t,e){<span class="cstat-no" title="statement not covered" >if(N(t)){var n=<span class="cstat-no" title="statement not covered" >this._trace;<span class="cstat-no" title="statement not covered" >if(void 0!==n&amp;&amp;e&amp;&amp;(n=n._parent),void 0!==n)<span class="cstat-no" title="statement not covered" >n.attachExtraTrace(t);else <span class="cstat-no" title="statement not covered" >if(!t.__stackCleaned__){var r=<span class="cstat-no" title="statement not covered" >j(t);<span class="cstat-no" title="statement not covered" >H.notEnumerableProp(t,"stack",r.message+"\n"+r.stack.join("\n")),H.notEnumerableProp(t,"__stackCleaned__",!0)}}</span>}</span></span>f</span>unction <span class="fstat-no" title="function not covered" >d(t,e,n,r,i){<span class="cstat-no" title="statement not covered" >if(void 0===t&amp;&amp;null!==e&amp;&amp;W){<span class="cstat-no" title="statement not covered" >if(void 0!==i&amp;&amp;i._returnedNonUndefined())<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===(65535&amp;r._bitField))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>&amp;&amp;(n+=" ");v</span>ar o=<span class="cstat-no" title="statement not covered" >"",s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >if(e._trace){<span class="cstat-no" title="statement not covered" >for(var a=e._trace.stack.split("\n"),c=w(a),l=c.length-1;l&gt;=0;--l){var u=<span class="cstat-no" title="statement not covered" >c[l];<span class="cstat-no" title="statement not covered" >if(!U.test(u)){var p=<span class="cstat-no" title="statement not covered" >u.match(M);<span class="cstat-no" title="statement not covered" >p&amp;&amp;(o="at "+p[1]+":"+p[2]+":"+p[3]+" ");<span class="cstat-no" title="statement not covered" >b</span>reak}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(c.length&gt;0)<span class="cstat-no" title="statement not covered" >for(var h=c[0],l=0;l&lt;a.length;++l)<span class="cstat-no" title="statement not covered" >if(a[l]===h){<span class="cstat-no" title="statement not covered" >l&gt;0&amp;&amp;(s="\n"+a[l-1]);<span class="cstat-no" title="statement not covered" >b</span>reak}}</span>v</span></span></span></span>ar f=<span class="cstat-no" title="statement not covered" >"a promise was created in a "+n+"handler "+o+"but was not returned from it, see http://goo.gl/rRqMUw"+s;<span class="cstat-no" title="statement not covered" >r._warn(f,!0,e)}}</span>f</span>unction <span class="fstat-no" title="function not covered" >v(t,e){var n=<span class="cstat-no" title="statement not covered" >t+" is deprecated and will be removed in a future version.";<span class="cstat-no" title="statement not covered" >return e&amp;&amp;(n+=" Use "+e+" instead."),y(n)}f</span>unction <span class="fstat-no" title="function not covered" >y(t,n,r){<span class="cstat-no" title="statement not covered" >if(ot.warnings){var i,o=<span class="cstat-no" title="statement not covered" >new L(t);<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >r._attachExtraTrace(o);else <span class="cstat-no" title="statement not covered" >if(ot.longStackTraces&amp;&amp;(i=e._peekContext()))<span class="cstat-no" title="statement not covered" >i.attachExtraTrace(o);else{var s=<span class="cstat-no" title="statement not covered" >j(o);<span class="cstat-no" title="statement not covered" >o.stack=s.message+"\n"+s.stack.join("\n")}<span class="cstat-no" title="statement not covered" >t</span></span></span>t("warning",o)||E(o,"",!0)}}</span>f</span>unction <span class="fstat-no" title="function not covered" >m(t,e){<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;e.length-1;++n)<span class="cstat-no" title="statement not covered" >e[n].push("From previous event:"),e[n]=e[n].join("\n");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n&lt;e.length&amp;&amp;(e[n]=e[n].join("\n")),t+"\n"+e.join("\n")}f</span>unction <span class="fstat-no" title="function not covered" >g(t){<span class="cstat-no" title="statement not covered" >for(var e=0;e&lt;t.length;++e)<span class="cstat-no" title="statement not covered" >(0===t[e].length||e+1&lt;t.length&amp;&amp;t[e][0]===t[e+1][0])&amp;&amp;(t.splice(e,1),e--)}f</span></span>unction <span class="fstat-no" title="function not covered" >b(t){<span class="cstat-no" title="statement not covered" >for(var e=t[0],n=1;n&lt;t.length;++n){<span class="cstat-no" title="statement not covered" >for(var r=t[n],i=e.length-1,o=e[i],s=-1,a=r.length-1;a&gt;=0;--a)<span class="cstat-no" title="statement not covered" >if(r[a]===o){<span class="cstat-no" title="statement not covered" >s=a;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var a=s;a&gt;=0;--a){var c=<span class="cstat-no" title="statement not covered" >r[a];<span class="cstat-no" title="statement not covered" >if(e[i]!==c)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >e</span></span>.pop(),i--}<span class="cstat-no" title="statement not covered" >e</span></span>=r}}</span>f</span>unction <span class="fstat-no" title="function not covered" >w(t){<span class="cstat-no" title="statement not covered" >for(var e=[],n=0;n&lt;t.length;++n){var r=<span class="cstat-no" title="statement not covered" >t[n],i=<span class="cstat-no" title="statement not covered" >"    (No stack trace)"===r||q.test(r),o=<span class="cstat-no" title="statement not covered" >i&amp;&amp;nt(r);<span class="cstat-no" title="statement not covered" >i&amp;&amp;!o&amp;&amp;($&amp;&amp;" "!==r.charAt(0)&amp;&amp;(r="    "+r),e.push(r))}<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}f</span>unction <span class="fstat-no" title="function not covered" >C(t){<span class="cstat-no" title="statement not covered" >for(var e=t.stack.replace(/\s+$/g,"").split("\n"),n=0;n&lt;e.length;++n){var r=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" >if("    (No stack trace)"===r||q.test(r))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n&gt;0&amp;&amp;"SyntaxError"!=t.name&amp;&amp;(e=e.slice(n)),e}f</span>unction <span class="fstat-no" title="function not covered" >j(t){var e=<span class="cstat-no" title="statement not covered" >t.stack,n=<span class="cstat-no" title="statement not covered" >t.toString();<span class="cstat-no" title="statement not covered" >return e="string"==typeof e&amp;&amp;e.length&gt;0?C(t):["    (No stack trace)"],{message:n,stack:"SyntaxError"==t.name?e:w(e)}}f</span>unction <span class="fstat-no" title="function not covered" >E(t,e,n){<span class="cstat-no" title="statement not covered" >if("undefined"!=typeof console){var r;<span class="cstat-no" title="statement not covered" >if(H.isObject(t)){var i=<span class="cstat-no" title="statement not covered" >t.stack;<span class="cstat-no" title="statement not covered" >r=e+Q(i,t)}e</span>lse <span class="cstat-no" title="statement not covered" >r=e+String(t);<span class="cstat-no" title="statement not covered" >"</span></span>function"==typeof D?D(r,n):("function"==typeof console.log||"object"==typeof console.log)&amp;&amp;void 0}}</span>f</span>unction <span class="fstat-no" title="function not covered" >k(t,e,n,r){var i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >"function"==typeof e&amp;&amp;(i=!0,"rejectionHandled"===t?e(r):e(n,r))}c</span>atch(o){<span class="cstat-no" title="statement not covered" >I.throwLater(o)}<span class="cstat-no" title="statement not covered" >"</span></span>unhandledRejection"===t?tt(t,n,r)||i||E(n,"Unhandled rejection "):tt(t,r)}f</span>unction <span class="fstat-no" title="function not covered" >F(t){var e;<span class="cstat-no" title="statement not covered" >if("function"==typeof t)<span class="cstat-no" title="statement not covered" >e="[function "+(t.name||"anonymous")+"]";else{<span class="cstat-no" title="statement not covered" >e=t&amp;&amp;"function"==typeof t.toString?t.toString():H.toString(t);v</span>ar n=<span class="cstat-no" title="statement not covered" >/\[object [a-zA-Z0-9$_]+\]/;<span class="cstat-no" title="statement not covered" >if(n.test(e))<span class="cstat-no" title="statement not covered" >try{var r=<span class="cstat-no" title="statement not covered" >JSON.stringify(t);<span class="cstat-no" title="statement not covered" >e=r}c</span>atch(i){}<span class="cstat-no" title="statement not covered" >0</span></span>===e.length&amp;&amp;(e="(empty array)")}<span class="cstat-no" title="statement not covered" >r</span></span>eturn"(&lt;"+x(e)+"&gt;, no stack trace)"}f</span>unction <span class="fstat-no" title="function not covered" >x(t){var e=<span class="cstat-no" title="statement not covered" >41;<span class="cstat-no" title="statement not covered" >return t.length&lt;e?t:t.substr(0,e-3)+"..."}f</span>unction <span class="fstat-no" title="function not covered" >T(){<span class="cstat-no" title="statement not covered" >return"function"==typeof it}f</span>unction <span class="fstat-no" title="function not covered" >P(t){var e=<span class="cstat-no" title="statement not covered" >t.match(rt);<span class="cstat-no" title="statement not covered" >return e?{fileName:e[1],line:parseInt(e[2],10)}:void 0}f</span>unction <span class="fstat-no" title="function not covered" >R(t,e){<span class="cstat-no" title="statement not covered" >if(T()){<span class="cstat-no" title="statement not covered" >for(var n,r,i=t.stack.split("\n"),o=e.stack.split("\n"),s=-1,a=-1,c=0;c&lt;i.length;++c){var l=<span class="cstat-no" title="statement not covered" >P(i[c]);<span class="cstat-no" title="statement not covered" >if(l){<span class="cstat-no" title="statement not covered" >n=l.fileName,s=l.line;<span class="cstat-no" title="statement not covered" >b</span>reak}}<span class="cstat-no" title="statement not covered" ></span>f</span></span>or(var c=0;c&lt;o.length;++c){var l=<span class="cstat-no" title="statement not covered" >P(o[c]);<span class="cstat-no" title="statement not covered" >if(l){<span class="cstat-no" title="statement not covered" >r=l.fileName,a=l.line;<span class="cstat-no" title="statement not covered" >b</span>reak}}<span class="cstat-no" title="statement not covered" ></span>0</span></span>&gt;s||0&gt;a||!n||!r||n!==r||s&gt;=a||(nt=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if(B.test(t))<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >P(t);<span class="cstat-no" title="statement not covered" >return!!(e&amp;&amp;e.fileName===n&amp;&amp;s&lt;=e.line&amp;&amp;e.line&lt;=a)})</span>}}</span>f</span>unction <span class="fstat-no" title="function not covered" >S(t){<span class="cstat-no" title="statement not covered" >this._parent=t,this._promisesCreated=0;v</span>ar e=<span class="cstat-no" title="statement not covered" >this._length=1+(void 0===t?0:t._length);<span class="cstat-no" title="statement not covered" >it(this,S),e&gt;32&amp;&amp;this.uncycle()}v</span>ar O,A,D,V=<span class="cstat-no" title="statement not covered" >e._getDomain,I=<span class="cstat-no" title="statement not covered" >e._async,L=<span class="cstat-no" title="statement not covered" >t("./errors").Warning,H=<span class="cstat-no" title="statement not covered" >t("./util"),N=<span class="cstat-no" title="statement not covered" >H.canAttachTrace,B=<span class="cstat-no" title="statement not covered" >/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,U=<span class="cstat-no" title="statement not covered" >/\((?:timers\.js):\d+:\d+\)/,M=<span class="cstat-no" title="statement not covered" >/[\/&lt;\(](.+?):(\d+):(\d+)\)?\s*$/,q=<span class="cstat-no" title="statement not covered" >null,Q=<span class="cstat-no" title="statement not covered" >null,$=<span class="cstat-no" title="statement not covered" >!1,G=<span class="cstat-no" title="statement not covered" >!(0==H.env("BLUEBIRD_DEBUG")||!H.env("BLUEBIRD_DEBUG")&amp;&amp;"development"!==H.env("NODE_ENV")),z=<span class="cstat-no" title="statement not covered" >!(0==H.env("BLUEBIRD_WARNINGS")||!G&amp;&amp;!H.env("BLUEBIRD_WARNINGS")),X=<span class="cstat-no" title="statement not covered" >!(0==H.env("BLUEBIRD_LONG_STACK_TRACES")||!G&amp;&amp;!H.env("BLUEBIRD_LONG_STACK_TRACES")),W=<span class="cstat-no" title="statement not covered" >0!=H.env("BLUEBIRD_W_FORGOTTEN_RETURN")&amp;&amp;(z||!!H.env("BLUEBIRD_W_FORGOTTEN_RETURN"));<span class="cstat-no" title="statement not covered" >e.prototype.suppressUnhandledRejections=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._target();<span class="cstat-no" title="statement not covered" >t._bitField=-1048577&amp;t._bitField|524288},</span>e.prototype._ensurePossibleRejectionHandled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >0===(524288&amp;this._bitField)&amp;&amp;(this._setRejectionIsUnhandled(),I.invokeLater(this._notifyUnhandledRejection,this,void 0))},</span>e.prototype._notifyUnhandledRejectionIsHandled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >k("rejectionHandled",O,void 0,this)},</span>e.prototype._setReturnedNonUndefined=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=268435456|this._bitField},</span>e.prototype._returnedNonUndefined=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(268435456&amp;this._bitField)},</span>e.prototype._notifyUnhandledRejection=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(this._isRejectionUnhandled()){var t=<span class="cstat-no" title="statement not covered" >this._settledValue();<span class="cstat-no" title="statement not covered" >this._setUnhandledRejectionIsNotified(),k("unhandledRejection",A,t,this)}}</span>,</span>e.prototype._setUnhandledRejectionIsNotified=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=262144|this._bitField},</span>e.prototype._unsetUnhandledRejectionIsNotified=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=-262145&amp;this._bitField},</span>e.prototype._isUnhandledRejectionNotified=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return(262144&amp;this._bitField)&gt;0},</span>e.prototype._setRejectionIsUnhandled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=1048576|this._bitField},</span>e.prototype._unsetRejectionIsUnhandled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=-1048577&amp;this._bitField,this._isUnhandledRejectionNotified()&amp;&amp;(this._unsetUnhandledRejectionIsNotified(),this._notifyUnhandledRejectionIsHandled())},</span>e.prototype._isRejectionUnhandled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return(1048576&amp;this._bitField)&gt;0},</span>e.prototype._warn=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return y(t,e,n||this)},</span>e.onPossiblyUnhandledRejection=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >V();<span class="cstat-no" title="statement not covered" >A="function"==typeof t?null===e?t:H.domainBind(e,t):void 0},</span>e.onUnhandledRejectionHandled=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >V();<span class="cstat-no" title="statement not covered" >O="function"==typeof t?null===e?t:H.domainBind(e,t):void 0};</span>v</span>ar K=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{};<span class="cstat-no" title="statement not covered" >e.longStackTraces=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(I.haveItemsQueued()&amp;&amp;!ot.longStackTraces)<span class="cstat-no" title="statement not covered" >throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");<span class="cstat-no" title="statement not covered" >i</span></span>f(!ot.longStackTraces&amp;&amp;T()){var t=<span class="cstat-no" title="statement not covered" >e.prototype._captureStackTrace,r=<span class="cstat-no" title="statement not covered" >e.prototype._attachExtraTrace;<span class="cstat-no" title="statement not covered" >ot.longStackTraces=!0,K=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(I.haveItemsQueued()&amp;&amp;!ot.longStackTraces)<span class="cstat-no" title="statement not covered" >throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");<span class="cstat-no" title="statement not covered" >e</span></span>.prototype._captureStackTrace=t,e.prototype._attachExtraTrace=r,n.deactivateLongStackTraces(),I.enableTrampoline(),ot.longStackTraces=!1},</span>e.prototype._captureStackTrace=f,e.prototype._attachExtraTrace=_,n.activateLongStackTraces(),I.disableTrampolineIfNecessary()}}</span>,</span>e.hasLongStackTraces=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return ot.longStackTraces&amp;&amp;T()};</span>v</span>ar J=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if("function"==typeof CustomEvent){var t=<span class="cstat-no" title="statement not covered" >new CustomEvent("CustomEvent");<span class="cstat-no" title="statement not covered" >return H.global.dispatchEvent(t),<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >new CustomEvent(t.toLowerCase(),{detail:e,cancelable:!0});<span class="cstat-no" title="statement not covered" >return!H.global.dispatchEvent(n)}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f("function"==typeof Event){var t=<span class="cstat-no" title="statement not covered" >new Event("CustomEvent");<span class="cstat-no" title="statement not covered" >return H.global.dispatchEvent(t),<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >new Event(t.toLowerCase(),{cancelable:!0});<span class="cstat-no" title="statement not covered" >return n.detail=e,!H.global.dispatchEvent(n)}}</span>v</span></span>ar t=<span class="cstat-no" title="statement not covered" >document.createEvent("CustomEvent");<span class="cstat-no" title="statement not covered" >return t.initCustomEvent("testingtheevent",!1,!0,{}),H.global.dispatchEvent(t),<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >document.createEvent("CustomEvent");<span class="cstat-no" title="statement not covered" >return n.initCustomEvent(t.toLowerCase(),!1,!0,e),!H.global.dispatchEvent(n)}}</span>c</span>atch(e){}<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return!1}}</span>(</span>),Y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return H.isNode?<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return process.emit.apply(process,arguments)}:</span>H.global?<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >"on"+t.toLowerCase(),n=<span class="cstat-no" title="statement not covered" >H.global[e];<span class="cstat-no" title="statement not covered" >return!!n&amp;&amp;(n.apply(H.global,[].slice.call(arguments,1)),!0)}:<span class="fstat-no" title="function not covered" ></span>function()</span>{<span class="cstat-no" title="statement not covered" >return!1}}</span>(</span>),Z=<span class="cstat-no" title="statement not covered" >{promiseCreated:r,promiseFulfilled:r,promiseRejected:r,promiseResolved:r,promiseCancelled:r,promiseChained:<span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return{promise:e,child:n}},</span>warning:<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return{warning:e}},</span>unhandledRejection:<span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return{reason:e,promise:n}},</span>rejectionHandled:r},tt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e=Y.apply(null,arguments)}c</span>atch(n){<span class="cstat-no" title="statement not covered" >I.throwLater(n),e=!0}v</span></span>ar r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=J(t,Z[t].apply(null,arguments))}c</span>atch(n){<span class="cstat-no" title="statement not covered" >I.throwLater(n),r=!0}<span class="cstat-no" title="statement not covered" >r</span></span>eturn r||e};<span class="cstat-no" title="statement not covered" ></span>e.config=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if(t=Object(t),"longStackTraces"in t&amp;&amp;(t.longStackTraces?e.longStackTraces():!t.longStackTraces&amp;&amp;e.hasLongStackTraces()&amp;&amp;K()),"warnings"in t){var n=<span class="cstat-no" title="statement not covered" >t.warnings;<span class="cstat-no" title="statement not covered" >ot.warnings=!!n,W=ot.warnings,H.isObject(n)&amp;&amp;"wForgottenReturn"in n&amp;&amp;(W=!!n.wForgottenReturn)}<span class="cstat-no" title="statement not covered" >i</span></span>f("cancellation"in t&amp;&amp;t.cancellation&amp;&amp;!ot.cancellation){<span class="cstat-no" title="statement not covered" >if(I.haveItemsQueued())<span class="cstat-no" title="statement not covered" >throw new Error("cannot enable cancellation after promises are in use");<span class="cstat-no" title="statement not covered" >e</span></span>.prototype._clearCancellationData=l,e.prototype._propagateFrom=u,e.prototype._onCancel=a,e.prototype._setOnCancel=c,e.prototype._attachCancellationCallback=s,e.prototype._execute=o,et=u,ot.cancellation=!0}<span class="cstat-no" title="statement not covered" >r</span></span>eturn"monitoring"in t&amp;&amp;(t.monitoring&amp;&amp;!ot.monitoring?(ot.monitoring=!0,e.prototype._fireEvent=tt):!t.monitoring&amp;&amp;ot.monitoring&amp;&amp;(ot.monitoring=!1,e.prototype._fireEvent=i)),e},</span>e.prototype._fireEvent=i,e.prototype._execute=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t(e,n)}c</span>atch(r){<span class="cstat-no" title="statement not covered" >return r}}</span>,</span>e.prototype._onCancel=<span class="fstat-no" title="function not covered" >function()</span>{},e.prototype._setOnCancel=<span class="fstat-no" title="function not covered" >function(</span>t){},e.prototype._attachCancellationCallback=<span class="fstat-no" title="function not covered" >function(</span>t){},e.prototype._captureStackTrace=<span class="fstat-no" title="function not covered" >function()</span>{},e.prototype._attachExtraTrace=<span class="fstat-no" title="function not covered" >function()</span>{},e.prototype._clearCancellationData=<span class="fstat-no" title="function not covered" >function()</span>{},e.prototype._propagateFrom=<span class="fstat-no" title="function not covered" >function(</span>t,e){};v</span>ar et=<span class="cstat-no" title="statement not covered" >p,nt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return!1},</span>rt=<span class="cstat-no" title="statement not covered" >/[\/&lt;\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;<span class="cstat-no" title="statement not covered" >H.inherits(S,Error),n.CapturedTrace=S,S.prototype.uncycle=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._length;<span class="cstat-no" title="statement not covered" >if(!(2&gt;t)){<span class="cstat-no" title="statement not covered" >for(var e=[],n={},r=0,i=this;void 0!==i;++r)<span class="cstat-no" title="statement not covered" >e.push(i),i=i._parent;<span class="cstat-no" title="statement not covered" >t</span></span>=this._length=r;<span class="cstat-no" title="statement not covered" >f</span>or(var r=t-1;r&gt;=0;--r){var o=<span class="cstat-no" title="statement not covered" >e[r].stack;<span class="cstat-no" title="statement not covered" >void 0===n[o]&amp;&amp;(n[o]=r)}<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=0;t&gt;r;++r){var s=<span class="cstat-no" title="statement not covered" >e[r].stack,a=<span class="cstat-no" title="statement not covered" >n[s];<span class="cstat-no" title="statement not covered" >if(void 0!==a&amp;&amp;a!==r){<span class="cstat-no" title="statement not covered" >a&gt;0&amp;&amp;(e[a-1]._parent=void 0,e[a-1]._length=1),e[r]._parent=void 0,e[r]._length=1;v</span>ar c=<span class="cstat-no" title="statement not covered" >r&gt;0?e[r-1]:this;<span class="cstat-no" title="statement not covered" >t-1&gt;a?(c._parent=e[a+1],c._parent.uncycle(),c._length=c._parent._length+1):(c._parent=void 0,c._length=1);<span class="cstat-no" title="statement not covered" >f</span>or(var l=c._length+1,u=r-2;u&gt;=0;--u)<span class="cstat-no" title="statement not covered" >e[u]._length=l,l++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn}}</span>}</span>}</span>,</span>S.prototype.attachExtraTrace=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if(!t.__stackCleaned__){<span class="cstat-no" title="statement not covered" >this.uncycle();<span class="cstat-no" title="statement not covered" >f</span>or(var e=j(t),n=e.message,r=[e.stack],i=this;void 0!==i;)<span class="cstat-no" title="statement not covered" >r.push(w(i.stack.split("\n"))),i=i._parent;<span class="cstat-no" title="statement not covered" >b</span></span>(r),g(r),H.notEnumerableProp(t,"stack",m(n,r)),H.notEnumerableProp(t,"__stackCleaned__",!0)}}</span>;</span>v</span>ar it=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >/^\s*at\s*/,e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return"string"==typeof t?t:void 0!==e.name&amp;&amp;void 0!==e.message?e.toString():F(e)};<span class="cstat-no" title="statement not covered" ></span>if("number"==typeof Error.stackTraceLimit&amp;&amp;"function"==typeof Error.captureStackTrace){<span class="cstat-no" title="statement not covered" >Error.stackTraceLimit+=6,q=t,Q=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >Error.captureStackTrace;<span class="cstat-no" title="statement not covered" >return nt=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return B.test(t)},<span class="fstat-no" title="function not covered" ></span>function(</span>t,e){<span class="cstat-no" title="statement not covered" >Error.stackTraceLimit+=6,n(t,e),Error.stackTraceLimit-=6}}</span>v</span></span>ar r=<span class="cstat-no" title="statement not covered" >new Error;<span class="cstat-no" title="statement not covered" >if("string"==typeof r.stack&amp;&amp;r.stack.split("\n")[0].indexOf("stackDetection@")&gt;=0)<span class="cstat-no" title="statement not covered" >return q=/@/,Q=e,$=!0,<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >t.stack=(new Error).stack};</span>v</span></span>ar i;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >throw new Error}c</span>atch(o){<span class="cstat-no" title="statement not covered" >i="stack"in o}<span class="cstat-no" title="statement not covered" >r</span></span>eturn"stack"in r||!i||"number"!=typeof Error.stackTraceLimit?(Q=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return"string"==typeof t?t:"object"!=typeof e&amp;&amp;"function"!=typeof e||void 0===e.name||void 0===e.message?F(e):e.toString()},</span>null):(q=t,Q=e,<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >Error.stackTraceLimit+=6;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >throw new Error}c</span>atch(e){<span class="cstat-no" title="statement not covered" >t.stack=e.stack}<span class="cstat-no" title="statement not covered" >E</span></span>rror.stackTraceLimit-=6})</span>}(</span>[]);<span class="cstat-no" title="statement not covered" >"undefined"!=typeof console&amp;&amp;"undefined"!=typeof console.warn&amp;&amp;(D=<span class="fstat-no" title="function not covered" >function(</span>t){},H.isNode&amp;&amp;process.stderr.isTTY?D=<span class="fstat-no" title="function not covered" >function(</span>t,e){}:H.isNode||"string"!=typeof(new Error).stack||(D=<span class="fstat-no" title="function not covered" >function(</span>t,e){}));v</span>ar ot=<span class="cstat-no" title="statement not covered" >{warnings:z,longStackTraces:!1,cancellation:!1,monitoring:!1};<span class="cstat-no" title="statement not covered" >return X&amp;&amp;e.longStackTraces(),{longStackTraces:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return ot.longStackTraces},</span>warnings:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return ot.warnings},</span>cancellation:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return ot.cancellation},</span>monitoring:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return ot.monitoring},</span>propagateFromFunction:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return et},</span>boundValueFunction:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return h},</span>checkForgottenReturns:d,setBounds:R,warn:y,deprecated:v,CapturedTrace:S,fireDomEvent:J,fireGlobalEvent:Y}}}</span>,</span>{"./errors":12,"./util":36}],10:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t){function <span class="fstat-no" title="function not covered" >e(){<span class="cstat-no" title="statement not covered" >return this.value}f</span>unction <span class="fstat-no" title="function not covered" >n(){<span class="cstat-no" title="statement not covered" >throw this.reason}<span class="cstat-no" title="statement not covered" >t</span>.prototype["return"]=t.prototype.thenReturn=<span class="fstat-no" title="function not covered" >function(</span>n){<span class="cstat-no" title="statement not covered" >return n instanceof t&amp;&amp;n.suppressUnhandledRejections(),this._then(e,void 0,void 0,{value:n},void 0)},</span>t.prototype["throw"]=t.prototype.thenThrow=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._then(n,void 0,void 0,{reason:t},void 0)},</span>t.prototype.catchThrow=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if(arguments.length&lt;=1)<span class="cstat-no" title="statement not covered" >return this._then(void 0,n,void 0,{reason:t},void 0);v</span></span>ar e=<span class="cstat-no" title="statement not covered" >arguments[1],r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >throw e};<span class="cstat-no" title="statement not covered" ></span>return this.caught(t,r)},</span>t.prototype.catchReturn=<span class="fstat-no" title="function not covered" >function(</span>n){<span class="cstat-no" title="statement not covered" >if(arguments.length&lt;=1)<span class="cstat-no" title="statement not covered" >return n instanceof t&amp;&amp;n.suppressUnhandledRejections(),this._then(void 0,e,void 0,{value:n},void 0);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >arguments[1];<span class="cstat-no" title="statement not covered" >r instanceof t&amp;&amp;r.suppressUnhandledRejections();v</span>ar i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return r};<span class="cstat-no" title="statement not covered" ></span>return this.caught(n,i)}}</span>}</span>,</span>{}],11:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t,e){function <span class="fstat-no" title="function not covered" >n(){<span class="cstat-no" title="statement not covered" >return o(this)}f</span>unction <span class="fstat-no" title="function not covered" >r(t,n){<span class="cstat-no" title="statement not covered" >return i(t,n,e,e)}v</span>ar i=<span class="cstat-no" title="statement not covered" >t.reduce,o=<span class="cstat-no" title="statement not covered" >t.all;<span class="cstat-no" title="statement not covered" >t.prototype.each=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return i(this,t,e,0)._then(n,void 0,void 0,this,void 0)},</span>t.prototype.mapSeries=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return i(this,t,e,e)},</span>t.each=<span class="fstat-no" title="function not covered" >function(</span>t,r){<span class="cstat-no" title="statement not covered" >return i(t,r,e,0)._then(n,void 0,void 0,t,void 0)},</span>t.mapSeries=r}}</span>,</span>{}],12:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";function <span class="fstat-no" title="function not covered" >r(t,e){function <span class="fstat-no" title="function not covered" >n(r){<span class="cstat-no" title="statement not covered" >return this instanceof n?(p(this,"message","string"==typeof r?r:e),p(this,"name",t),void(Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):Error.call(this))):new n(r)}<span class="cstat-no" title="statement not covered" >r</span>eturn u(n,Error),n}f</span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >return this instanceof i?(p(this,"name","OperationalError"),p(this,"message",t),this.cause=t,this.isOperational=!0,void(t instanceof Error?(p(this,"message",t.message),p(this,"stack",t.stack)):Error.captureStackTrace&amp;&amp;Error.captureStackTrace(this,this.constructor))):new i(t)}v</span>ar o,s,a=<span class="cstat-no" title="statement not covered" >t("./es5"),c=<span class="cstat-no" title="statement not covered" >a.freeze,l=<span class="cstat-no" title="statement not covered" >t("./util"),u=<span class="cstat-no" title="statement not covered" >l.inherits,p=<span class="cstat-no" title="statement not covered" >l.notEnumerableProp,h=<span class="cstat-no" title="statement not covered" >r("Warning","warning"),f=<span class="cstat-no" title="statement not covered" >r("CancellationError","cancellation error"),_=<span class="cstat-no" title="statement not covered" >r("TimeoutError","timeout error"),d=<span class="cstat-no" title="statement not covered" >r("AggregateError","aggregate error");<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >o=TypeError,s=RangeError}c</span>atch(v){<span class="cstat-no" title="statement not covered" >o=r("TypeError","type error"),s=r("RangeError","range error")}<span class="cstat-no" title="statement not covered" >f</span></span>or(var y="join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "),m=0;m&lt;y.length;++m)<span class="cstat-no" title="statement not covered" >"function"==typeof Array.prototype[y[m]]&amp;&amp;(d.prototype[y[m]]=Array.prototype[y[m]]);<span class="cstat-no" title="statement not covered" >a</span></span>.defineProperty(d.prototype,"length",{value:0,configurable:!1,writable:!0,enumerable:!0}),d.prototype.isOperational=!0;v</span>ar g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >d.prototype.toString=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >Array(4*g+1).join(" "),e=<span class="cstat-no" title="statement not covered" >"\n"+t+"AggregateError of:\n";<span class="cstat-no" title="statement not covered" >g++,t=Array(4*g+1).join(" ");<span class="cstat-no" title="statement not covered" >f</span>or(var n=0;n&lt;this.length;++n){<span class="cstat-no" title="statement not covered" >for(var r=this[n]===this?"[Circular AggregateError]":this[n]+"",i=r.split("\n"),o=0;o&lt;i.length;++o)<span class="cstat-no" title="statement not covered" >i[o]=t+i[o];<span class="cstat-no" title="statement not covered" >r</span></span>=i.join("\n"),e+=r+"\n"}<span class="cstat-no" title="statement not covered" >r</span></span>eturn g--,e},</span>u(i,Error);v</span>ar b=<span class="cstat-no" title="statement not covered" >Error.__BluebirdErrorTypes__;<span class="cstat-no" title="statement not covered" >b||(b=c({CancellationError:f,TimeoutError:_,OperationalError:i,RejectionError:i,AggregateError:d}),a.defineProperty(Error,"__BluebirdErrorTypes__",{value:b,writable:!1,enumerable:!1,configurable:!1})),e.exports={Error:Error,TypeError:o,RangeError:s,CancellationError:b.CancellationError,OperationalError:b.OperationalError,TimeoutError:b.TimeoutError,AggregateError:b.AggregateError,Warning:h}},</span>{"./es5":13,"./util":36}],13:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{"use strict";<span class="cstat-no" title="statement not covered" >return void 0===this}(</span>);<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >e.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:r,propertyIsWritable:<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(t,e);<span class="cstat-no" title="statement not covered" >return!(n&amp;&amp;!n.writable&amp;&amp;!n.set)}}</span>;else{var i=<span class="cstat-no" title="statement not covered" >{}.hasOwnProperty,o=<span class="cstat-no" title="statement not covered" >{}.toString,s=<span class="cstat-no" title="statement not covered" >{}.constructor.prototype,a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >i.call(t,n)&amp;&amp;e.push(n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e},</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return{value:t[e]}},</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return t[e]=n.value,t},</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t},</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Object(t).constructor.prototype}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return s}}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return"[object Array]"===o.call(t)}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return!1}}</span>;<span class="cstat-no" title="statement not covered" ></span>e.exports={isArray:h,keys:a,names:a,defineProperty:l,getDescriptor:c,freeze:u,getPrototypeOf:p,isES5:r,propertyIsWritable:<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return!0}}</span>}}</span>,</span>{}],14:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.map;<span class="cstat-no" title="statement not covered" >t.prototype.filter=<span class="fstat-no" title="function not covered" >function(</span>t,r){<span class="cstat-no" title="statement not covered" >return n(this,t,r,e)},</span>t.filter=<span class="fstat-no" title="function not covered" >function(</span>t,r,i){<span class="cstat-no" title="statement not covered" >return n(t,r,i,e)}}</span>}</span>,</span>{}],15:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n){function <span class="fstat-no" title="function not covered" >r(t,e,n){<span class="cstat-no" title="statement not covered" >this.promise=t,this.type=e,this.handler=n,this.called=!1,this.cancelPromise=null}f</span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >this.finallyHandler=t}f</span>unction <span class="fstat-no" title="function not covered" >o(t,e){<span class="cstat-no" title="statement not covered" >return null!=t.cancelPromise&amp;&amp;(arguments.length&gt;1?t.cancelPromise._reject(e):t.cancelPromise._cancel(),t.cancelPromise=null,!0)}f</span>unction <span class="fstat-no" title="function not covered" >s(){<span class="cstat-no" title="statement not covered" >return c.call(this,this.promise._target()._settledValue())}f</span>unction <span class="fstat-no" title="function not covered" >a(t){<span class="cstat-no" title="statement not covered" >return o(this,t)?void 0:(p.e=t,p)}f</span>unction <span class="fstat-no" title="function not covered" >c(t){var r=<span class="cstat-no" title="statement not covered" >this.promise,c=<span class="cstat-no" title="statement not covered" >this.handler;<span class="cstat-no" title="statement not covered" >if(!this.called){<span class="cstat-no" title="statement not covered" >this.called=!0;v</span>ar l=<span class="cstat-no" title="statement not covered" >this.isFinallyHandler()?c.call(r._boundValue()):c.call(r._boundValue(),t);<span class="cstat-no" title="statement not covered" >if(void 0!==l){<span class="cstat-no" title="statement not covered" >r._setReturnedNonUndefined();v</span>ar h=<span class="cstat-no" title="statement not covered" >n(l,r);<span class="cstat-no" title="statement not covered" >if(h instanceof e){<span class="cstat-no" title="statement not covered" >if(null!=this.cancelPromise){<span class="cstat-no" title="statement not covered" >if(h._isCancelled()){var f=<span class="cstat-no" title="statement not covered" >new u("late cancellation observer");<span class="cstat-no" title="statement not covered" >return r._attachExtraTrace(f),p.e=f,p}<span class="cstat-no" title="statement not covered" >h</span></span>.isPending()&amp;&amp;h._attachCancellationCallback(new i(this))}<span class="cstat-no" title="statement not covered" >r</span></span>eturn h._then(s,a,void 0,this,void 0)}}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn r.isRejected()?(o(this),p.e=t,p):(o(this),t)}v</span>ar l=<span class="cstat-no" title="statement not covered" >t("./util"),u=<span class="cstat-no" title="statement not covered" >e.CancellationError,p=<span class="cstat-no" title="statement not covered" >l.errorObj;<span class="cstat-no" title="statement not covered" >return r.prototype.isFinallyHandler=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0===this.type},</span>i.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >o(this.finallyHandler)},</span>e.prototype._passThrough=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >return"function"!=typeof t?this.then():this._then(n,i,void 0,new r(this,e,t),void 0)},</span>e.prototype.lastly=e.prototype["finally"]=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._passThrough(t,0,c,c)},</span>e.prototype.tap=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._passThrough(t,1,c)},</span>r}}</span>,</span>{"./util":36}],16:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o,s){function <span class="fstat-no" title="function not covered" >a(t,n,r){<span class="cstat-no" title="statement not covered" >for(var o=0;o&lt;n.length;++o){<span class="cstat-no" title="statement not covered" >r._pushContext();v</span>ar s=<span class="cstat-no" title="statement not covered" >f(n[o])(t);<span class="cstat-no" title="statement not covered" >if(r._popContext(),s===h){<span class="cstat-no" title="statement not covered" >r._pushContext();v</span>ar a=<span class="cstat-no" title="statement not covered" >e.reject(h.e);<span class="cstat-no" title="statement not covered" >return r._popContext(),a}v</span></span>ar c=<span class="cstat-no" title="statement not covered" >i(s,r);<span class="cstat-no" title="statement not covered" >if(c instanceof e)<span class="cstat-no" title="statement not covered" >return c}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn null}f</span>unction <span class="fstat-no" title="function not covered" >c(t,n,i,o){<span class="cstat-no" title="statement not covered" >if(s.cancellation()){var a=<span class="cstat-no" title="statement not covered" >new e(r),c=<span class="cstat-no" title="statement not covered" >this._finallyPromise=new e(r);<span class="cstat-no" title="statement not covered" >this._promise=a.lastly(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return c})</span>,a._captureStackTrace(),a._setOnCancel(this)}e</span>lse{var l=<span class="cstat-no" title="statement not covered" >this._promise=new e(r);<span class="cstat-no" title="statement not covered" >l._captureStackTrace()}<span class="cstat-no" title="statement not covered" >t</span></span>his._stack=o,this._generatorFunction=t,this._receiver=n,this._generator=void 0,this._yieldHandlers="function"==typeof i?[i].concat(_):_,this._yieldedPromise=null,this._cancellationPhase=!1}v</span>ar l=<span class="cstat-no" title="statement not covered" >t("./errors"),u=<span class="cstat-no" title="statement not covered" >l.TypeError,p=<span class="cstat-no" title="statement not covered" >t("./util"),h=<span class="cstat-no" title="statement not covered" >p.errorObj,f=<span class="cstat-no" title="statement not covered" >p.tryCatch,_=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" >p.inherits(c,o),c.prototype._isResolved=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return null===this._promise},</span>c.prototype._cleanup=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._promise=this._generator=null,s.cancellation()&amp;&amp;null!==this._finallyPromise&amp;&amp;(this._finallyPromise._fulfill(),this._finallyPromise=null)},</span>c.prototype._promiseCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(!this._isResolved()){var t,n=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof this._generator["return"];<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >this._promise._pushContext(),t=f(this._generator["return"]).call(this._generator,void 0),this._promise._popContext();else{var r=<span class="cstat-no" title="statement not covered" >new e.CancellationError("generator .return() sentinel");<span class="cstat-no" title="statement not covered" >e.coroutine.returnSentinel=r,this._promise._attachExtraTrace(r),this._promise._pushContext(),t=f(this._generator["throw"]).call(this._generator,r),this._promise._popContext()}<span class="cstat-no" title="statement not covered" >t</span></span>his._cancellationPhase=!0,this._yieldedPromise=null,this._continue(t)}}</span>,</span>c.prototype._promiseFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._yieldedPromise=null,this._promise._pushContext();v</span>ar e=<span class="cstat-no" title="statement not covered" >f(this._generator.next).call(this._generator,t);<span class="cstat-no" title="statement not covered" >this._promise._popContext(),this._continue(e)},</span>c.prototype._promiseRejected=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._yieldedPromise=null,this._promise._attachExtraTrace(t),this._promise._pushContext();v</span>ar e=<span class="cstat-no" title="statement not covered" >f(this._generator["throw"]).call(this._generator,t);<span class="cstat-no" title="statement not covered" >this._promise._popContext(),this._continue(e)},</span>c.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(this._yieldedPromise instanceof e){var t=<span class="cstat-no" title="statement not covered" >this._yieldedPromise;<span class="cstat-no" title="statement not covered" >this._yieldedPromise=null,t.cancel()}}</span>,</span>c.prototype.promise=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._promise},</span>c.prototype._run=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._generator=this._generatorFunction.call(this._receiver),this._receiver=this._generatorFunction=void 0,this._promiseFulfilled(void 0)},</span>c.prototype._continue=<span class="fstat-no" title="function not covered" >function(</span>t){var n=<span class="cstat-no" title="statement not covered" >this._promise;<span class="cstat-no" title="statement not covered" >if(t===h)<span class="cstat-no" title="statement not covered" >return this._cleanup(),this._cancellationPhase?n.cancel():n._rejectCallback(t.e,!1);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t.value;<span class="cstat-no" title="statement not covered" >if(t.done===!0)<span class="cstat-no" title="statement not covered" >return this._cleanup(),this._cancellationPhase?n.cancel():n._resolveCallback(r);v</span></span>ar o=<span class="cstat-no" title="statement not covered" >i(r,this._promise);<span class="cstat-no" title="statement not covered" >if(!(o instanceof e)&amp;&amp;(o=a(o,this._yieldHandlers,this._promise),null===o))<span class="cstat-no" title="statement not covered" >return void this._promiseRejected(new u("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s",r)+"From coroutine:\n"+this._stack.split("\n").slice(1,-7).join("\n")));<span class="cstat-no" title="statement not covered" >o</span></span>=o._target();v</span>ar s=<span class="cstat-no" title="statement not covered" >o._bitField;<span class="cstat-no" title="statement not covered" >0===(50397184&amp;s)?(this._yieldedPromise=o,o._proxy(this,null)):0!==(33554432&amp;s)?e._async.invoke(this._promiseFulfilled,this,o._value()):0!==(16777216&amp;s)?e._async.invoke(this._promiseRejected,this,o._reason()):this._promiseCancelled()},</span>e.coroutine=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new u("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Object(e).yieldHandler,r=<span class="cstat-no" title="statement not covered" >c,i=(<span class="cstat-no" title="statement not covered" >new Error).stack;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function()</span>{var e=<span class="cstat-no" title="statement not covered" >t.apply(this,arguments),o=<span class="cstat-no" title="statement not covered" >new r((void 0),(void 0),n,i),s=<span class="cstat-no" title="statement not covered" >o.promise();<span class="cstat-no" title="statement not covered" >return o._generator=e,o._promiseFulfilled(void 0),s}}</span>,</span>e.coroutine.addYieldHandler=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new u("expecting a function but got "+p.classString(t));<span class="cstat-no" title="statement not covered" >_</span></span>.push(t);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
},e.spawn=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if(s.deprecated("Promise.spawn()","Promise.coroutine()"),"function"!=typeof t)<span class="cstat-no" title="statement not covered" >return n("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");v</span></span>ar r=<span class="cstat-no" title="statement not covered" >new c(t,this),i=<span class="cstat-no" title="statement not covered" >r.promise();<span class="cstat-no" title="statement not covered" >return r._run(e.spawn),i}}</span>},{"./errors":12,"./util":36}],17:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o,s){var a=<span class="cstat-no" title="statement not covered" >t("./util");<span class="cstat-no" title="statement not covered" >a.canEvaluate,a.tryCatch,a.errorObj,e.join=<span class="fstat-no" title="function not covered" >function()</span>{var t,e=<span class="cstat-no" title="statement not covered" >arguments.length-1;<span class="cstat-no" title="statement not covered" >if(e&gt;0&amp;&amp;"function"==typeof arguments[e]){<span class="cstat-no" title="statement not covered" >t=arguments[e];v</span>ar r}v</span>ar i=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments);<span class="cstat-no" title="statement not covered" >t&amp;&amp;i.pop();v</span>ar r=<span class="cstat-no" title="statement not covered" >new n(i).promise();<span class="cstat-no" title="statement not covered" >return void 0!==t?r.spread(t):r}}</span>}</span>,</span>{"./util":36}],18:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o,s){function <span class="fstat-no" title="function not covered" >a(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.constructor$(t),this._promise._captureStackTrace();v</span>ar i=<span class="cstat-no" title="statement not covered" >l();<span class="cstat-no" title="statement not covered" >this._callback=null===i?e:u.domainBind(i,e),this._preservedValues=r===o?new Array(this.length()):null,this._limit=n,this._inFlight=0,this._queue=[],f.invoke(this._asyncInit,this,void 0)}f</span>unction <span class="fstat-no" title="function not covered" >c(t,n,i,o){<span class="cstat-no" title="statement not covered" >if("function"!=typeof n)<span class="cstat-no" title="statement not covered" >return r("expecting a function but got "+u.classString(n));v</span></span>ar s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >if(void 0!==i){<span class="cstat-no" title="statement not covered" >if("object"!=typeof i||null===i)<span class="cstat-no" title="statement not covered" >return e.reject(new TypeError("options argument must be an object but it is "+u.classString(i)));<span class="cstat-no" title="statement not covered" >i</span></span>f("number"!=typeof i.concurrency)<span class="cstat-no" title="statement not covered" >return e.reject(new TypeError("'concurrency' must be a number but it is "+u.classString(i.concurrency)));<span class="cstat-no" title="statement not covered" >s</span></span>=i.concurrency}<span class="cstat-no" title="statement not covered" >r</span></span>eturn s="number"==typeof s&amp;&amp;isFinite(s)&amp;&amp;s&gt;=1?s:0,new a(t,n,s,o).promise()}v</span>ar l=<span class="cstat-no" title="statement not covered" >e._getDomain,u=<span class="cstat-no" title="statement not covered" >t("./util"),p=<span class="cstat-no" title="statement not covered" >u.tryCatch,h=<span class="cstat-no" title="statement not covered" >u.errorObj,f=<span class="cstat-no" title="statement not covered" >e._async;<span class="cstat-no" title="statement not covered" >u.inherits(a,n),a.prototype._asyncInit=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._init$(void 0,-2)},</span>a.prototype._init=<span class="fstat-no" title="function not covered" >function()</span>{},a.prototype._promiseFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t,n){var r=<span class="cstat-no" title="statement not covered" >this._values,o=<span class="cstat-no" title="statement not covered" >this.length(),a=<span class="cstat-no" title="statement not covered" >this._preservedValues,c=<span class="cstat-no" title="statement not covered" >this._limit;<span class="cstat-no" title="statement not covered" >if(0&gt;n){<span class="cstat-no" title="statement not covered" >if(n=-1*n-1,r[n]=t,c&gt;=1&amp;&amp;(this._inFlight--,this._drainQueue(),this._isResolved()))<span class="cstat-no" title="statement not covered" >return!0}e</span></span>lse{<span class="cstat-no" title="statement not covered" >if(c&gt;=1&amp;&amp;this._inFlight&gt;=c)<span class="cstat-no" title="statement not covered" >return r[n]=t,this._queue.push(n),!1;<span class="cstat-no" title="statement not covered" >n</span></span>ull!==a&amp;&amp;(a[n]=t);v</span>ar l=<span class="cstat-no" title="statement not covered" >this._promise,u=<span class="cstat-no" title="statement not covered" >this._callback,f=<span class="cstat-no" title="statement not covered" >l._boundValue();<span class="cstat-no" title="statement not covered" >l._pushContext();v</span>ar _=<span class="cstat-no" title="statement not covered" >p(u).call(f,t,n,o),d=<span class="cstat-no" title="statement not covered" >l._popContext();<span class="cstat-no" title="statement not covered" >if(s.checkForgottenReturns(_,d,null!==a?"Promise.filter":"Promise.map",l),_===h)<span class="cstat-no" title="statement not covered" >return this._reject(_.e),!0;v</span></span>ar v=<span class="cstat-no" title="statement not covered" >i(_,this._promise);<span class="cstat-no" title="statement not covered" >if(v instanceof e){<span class="cstat-no" title="statement not covered" >v=v._target();v</span>ar y=<span class="cstat-no" title="statement not covered" >v._bitField;<span class="cstat-no" title="statement not covered" >if(0===(50397184&amp;y))<span class="cstat-no" title="statement not covered" >return c&gt;=1&amp;&amp;this._inFlight++,r[n]=v,v._proxy(this,-1*(n+1)),!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===(33554432&amp;y))<span class="cstat-no" title="statement not covered" >return 0!==(16777216&amp;y)?(this._reject(v._reason()),!0):(this._cancel(),!0);<span class="cstat-no" title="statement not covered" >_</span></span>=v._value()}<span class="cstat-no" title="statement not covered" >r</span></span>[n]=_}v</span></span>ar m=<span class="cstat-no" title="statement not covered" >++this._totalResolved;<span class="cstat-no" title="statement not covered" >return m&gt;=o&amp;&amp;(null!==a?this._filter(r,a):this._resolve(r),!0)},</span>a.prototype._drainQueue=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >for(var t=this._queue,e=this._limit,n=this._values;t.length&gt;0&amp;&amp;this._inFlight&lt;e;){<span class="cstat-no" title="statement not covered" >if(this._isResolved())<span class="cstat-no" title="statement not covered" >return;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t.pop();<span class="cstat-no" title="statement not covered" >this._promiseFulfilled(n[r],r)}}</span>,</span>a.prototype._filter=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=e.length,r=new Array(n),i=0,o=0;n&gt;o;++o)<span class="cstat-no" title="statement not covered" >t[o]&amp;&amp;(r[i++]=e[o]);<span class="cstat-no" title="statement not covered" >r</span></span>.length=i,this._resolve(r)},</span>a.prototype.preservedValues=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._preservedValues},</span>e.prototype.map=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return c(this,t,e,null)},</span>e.map=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >return c(t,e,n,r)}}</span>}</span>,</span>{"./util":36}],19:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o){var s=<span class="cstat-no" title="statement not covered" >t("./util"),a=<span class="cstat-no" title="statement not covered" >s.tryCatch;<span class="cstat-no" title="statement not covered" >e.method=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new e.TypeError("expecting a function but got "+s.classString(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >function()</span>{var r=<span class="cstat-no" title="statement not covered" >new e(n);<span class="cstat-no" title="statement not covered" >r._captureStackTrace(),r._pushContext();v</span>ar i=<span class="cstat-no" title="statement not covered" >a(t).apply(this,arguments),s=<span class="cstat-no" title="statement not covered" >r._popContext();<span class="cstat-no" title="statement not covered" >return o.checkForgottenReturns(i,s,"Promise.method",r),r._resolveFromSyncValue(i),r}}</span>,</span>e.attempt=e["try"]=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >return i("expecting a function but got "+s.classString(t));v</span></span>ar r=<span class="cstat-no" title="statement not covered" >new e(n);<span class="cstat-no" title="statement not covered" >r._captureStackTrace(),r._pushContext();v</span>ar c;<span class="cstat-no" title="statement not covered" >if(arguments.length&gt;1){<span class="cstat-no" title="statement not covered" >o.deprecated("calling Promise.try with more than 1 argument");v</span>ar l=<span class="cstat-no" title="statement not covered" >arguments[1],u=<span class="cstat-no" title="statement not covered" >arguments[2];<span class="cstat-no" title="statement not covered" >c=s.isArray(l)?a(t).apply(u,l):a(t).call(u,l)}e</span>lse <span class="cstat-no" title="statement not covered" >c=a(t)();v</span></span>ar p=<span class="cstat-no" title="statement not covered" >r._popContext();<span class="cstat-no" title="statement not covered" >return o.checkForgottenReturns(c,p,"Promise.try",r),r._resolveFromSyncValue(c),r},</span>e.prototype._resolveFromSyncValue=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >t===s.errorObj?this._rejectCallback(t.e,!1):this._resolveCallback(t,!0)}}</span>}</span>,</span>{"./util":36}],20:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";function <span class="fstat-no" title="function not covered" >r(t){<span class="cstat-no" title="statement not covered" >return t instanceof Error&amp;&amp;u.getPrototypeOf(t)===Error.prototype}f</span>unction <span class="fstat-no" title="function not covered" >i(t){var e;<span class="cstat-no" title="statement not covered" >if(r(t)){<span class="cstat-no" title="statement not covered" >e=new l(t),e.name=t.name,e.message=t.message,e.stack=t.stack;<span class="cstat-no" title="statement not covered" >f</span>or(var n=u.keys(t),i=0;i&lt;n.length;++i){var o=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" >p.test(o)||(e[o]=t[o])}<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.markAsOriginatingFromRejection(t),t}f</span>unction <span class="fstat-no" title="function not covered" >o(t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(</span>n,r){<span class="cstat-no" title="statement not covered" >if(null!==t){<span class="cstat-no" title="statement not covered" >if(n){var o=<span class="cstat-no" title="statement not covered" >i(a(n));<span class="cstat-no" title="statement not covered" >t._attachExtraTrace(o),t._reject(o)}e</span>lse <span class="cstat-no" title="statement not covered" >if(e){var s=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,1);<span class="cstat-no" title="statement not covered" >t._fulfill(s)}e</span>lse <span class="cstat-no" title="statement not covered" >t._fulfill(r);<span class="cstat-no" title="statement not covered" >t</span></span></span>=null}}</span>}</span>v</span>ar s=<span class="cstat-no" title="statement not covered" >t("./util"),a=<span class="cstat-no" title="statement not covered" >s.maybeWrapAsError,c=<span class="cstat-no" title="statement not covered" >t("./errors"),l=<span class="cstat-no" title="statement not covered" >c.OperationalError,u=<span class="cstat-no" title="statement not covered" >t("./es5"),p=<span class="cstat-no" title="statement not covered" >/^(?:name|message|stack|cause)$/;<span class="cstat-no" title="statement not covered" >e.exports=o},</span>{"./errors":12,"./es5":13,"./util":36}],21:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e){function <span class="fstat-no" title="function not covered" >n(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" >if(!o.isArray(t))<span class="cstat-no" title="statement not covered" >return r.call(n,t,e);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >a(e).apply(n._boundValue(),[null].concat(t));<span class="cstat-no" title="statement not covered" >i===c&amp;&amp;s.throwLater(i.e)}f</span>unction <span class="fstat-no" title="function not covered" >r(t,e){var n=<span class="cstat-no" title="statement not covered" >this,r=<span class="cstat-no" title="statement not covered" >n._boundValue(),i=<span class="cstat-no" title="statement not covered" >void 0===t?a(e).call(r,null):a(e).call(r,null,t);<span class="cstat-no" title="statement not covered" >i===c&amp;&amp;s.throwLater(i.e)}f</span>unction <span class="fstat-no" title="function not covered" >i(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" >if(!t){var r=<span class="cstat-no" title="statement not covered" >new Error(t+"");<span class="cstat-no" title="statement not covered" >r.cause=t,t=r}v</span></span>ar i=<span class="cstat-no" title="statement not covered" >a(e).call(n._boundValue(),t);<span class="cstat-no" title="statement not covered" >i===c&amp;&amp;s.throwLater(i.e)}v</span>ar o=<span class="cstat-no" title="statement not covered" >t("./util"),s=<span class="cstat-no" title="statement not covered" >e._async,a=<span class="cstat-no" title="statement not covered" >o.tryCatch,c=<span class="cstat-no" title="statement not covered" >o.errorObj;<span class="cstat-no" title="statement not covered" >e.prototype.asCallback=e.prototype.nodeify=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if("function"==typeof t){var o=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >void 0!==e&amp;&amp;Object(e).spread&amp;&amp;(o=n),this._then(o,i,void 0,this,t)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}}</span>}</span>,</span>{"./util":36}],22:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function()</span>{function <span class="fstat-no" title="function not covered" >n(){}function <span class="fstat-no" title="function not covered" >r(t,e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new m("expecting a function but got "+f.classString(e));<span class="cstat-no" title="statement not covered" >i</span></span>f(t.constructor!==i)<span class="cstat-no" title="statement not covered" >throw new m("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n")}f</span></span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >this._bitField=0,this._fulfillmentHandler0=void 0,this._rejectionHandler0=void 0,this._promise0=void 0,this._receiver0=void 0,t!==b&amp;&amp;(r(this,t),this._resolveFromExecutor(t)),this._promiseCreated(),this._fireEvent("promiseCreated",this)}f</span>unction <span class="fstat-no" title="function not covered" >o(t){<span class="cstat-no" title="statement not covered" >this.promise._resolveCallback(t)}f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >this.promise._rejectCallback(t,!1)}f</span>unction <span class="fstat-no" title="function not covered" >a(t){var e=<span class="cstat-no" title="statement not covered" >new i(b);<span class="cstat-no" title="statement not covered" >e._fulfillmentHandler0=t,e._rejectionHandler0=t,e._promise0=t,e._receiver0=t}v</span>ar c,l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return new m("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n")},</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return new i.PromiseInspection(this._target())},</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return i.reject(new m(t))},</span>h=<span class="cstat-no" title="statement not covered" >{},f=<span class="cstat-no" title="statement not covered" >t("./util");<span class="cstat-no" title="statement not covered" >c=f.isNode?<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >process.domain;<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=null),t}:<span class="fstat-no" title="function not covered" ></span>function()</span>{<span class="cstat-no" title="statement not covered" >return null},</span>f.notEnumerableProp(i,"_getDomain",c);v</span>ar _=<span class="cstat-no" title="statement not covered" >t("./es5"),d=<span class="cstat-no" title="statement not covered" >t("./async"),v=<span class="cstat-no" title="statement not covered" >new d;<span class="cstat-no" title="statement not covered" >_.defineProperty(i,"_async",{value:v});v</span>ar y=<span class="cstat-no" title="statement not covered" >t("./errors"),m=<span class="cstat-no" title="statement not covered" >i.TypeError=y.TypeError;<span class="cstat-no" title="statement not covered" >i.RangeError=y.RangeError;v</span>ar g=<span class="cstat-no" title="statement not covered" >i.CancellationError=y.CancellationError;<span class="cstat-no" title="statement not covered" >i.TimeoutError=y.TimeoutError,i.OperationalError=y.OperationalError,i.RejectionError=y.OperationalError,i.AggregateError=y.AggregateError;v</span>ar b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{},w=<span class="cstat-no" title="statement not covered" >{},C=<span class="cstat-no" title="statement not covered" >{},j=<span class="cstat-no" title="statement not covered" >t("./thenables")(i,b),E=<span class="cstat-no" title="statement not covered" >t("./promise_array")(i,b,j,p,n),k=<span class="cstat-no" title="statement not covered" >t("./context")(i),F=<span class="cstat-no" title="statement not covered" >k.create,x=<span class="cstat-no" title="statement not covered" >t("./debuggability")(i,k),T=(<span class="cstat-no" title="statement not covered" >x.CapturedTrace,t("./finally")(i,j)),P=<span class="cstat-no" title="statement not covered" >t("./catch_filter")(C),R=<span class="cstat-no" title="statement not covered" >t("./nodeback"),S=<span class="cstat-no" title="statement not covered" >f.errorObj,O=<span class="cstat-no" title="statement not covered" >f.tryCatch;<span class="cstat-no" title="statement not covered" >return i.prototype.toString=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return"[object Promise]"},</span>i.prototype.caught=i.prototype["catch"]=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" >if(e&gt;1){var n,r=<span class="cstat-no" title="statement not covered" >new Array(e-1),i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >for(n=0;e-1&gt;n;++n){var o=<span class="cstat-no" title="statement not covered" >arguments[n];<span class="cstat-no" title="statement not covered" >if(!f.isObject(o))<span class="cstat-no" title="statement not covered" >return p("expecting an object but got A catch statement predicate "+f.classString(o));<span class="cstat-no" title="statement not covered" >r</span></span>[i++]=o}<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.length=i,t=arguments[n],this.then(void 0,P(r,t,this))}<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.then(void 0,t)},</span>i.prototype.reflect=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._then(u,u,void 0,this,void 0)},</span>i.prototype.then=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if(x.warnings()&amp;&amp;arguments.length&gt;0&amp;&amp;"function"!=typeof t&amp;&amp;"function"!=typeof e){var n=<span class="cstat-no" title="statement not covered" >".then() only accepts functions but was passed: "+f.classString(t);<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;(n+=", "+f.classString(e)),this._warn(n)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._then(t,e,void 0,void 0,void 0)},</span>i.prototype.done=<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >this._then(t,e,void 0,void 0,void 0);<span class="cstat-no" title="statement not covered" >n._setIsFinal()},</span>i.prototype.spread=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return"function"!=typeof t?p("expecting a function but got "+f.classString(t)):this.all()._then(t,void 0,void 0,w,void 0)},</span>i.prototype.toJSON=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >{isFulfilled:!1,isRejected:!1,fulfillmentValue:void 0,rejectionReason:void 0};<span class="cstat-no" title="statement not covered" >return this.isFulfilled()?(t.fulfillmentValue=this.value(),t.isFulfilled=!0):this.isRejected()&amp;&amp;(t.rejectionReason=this.reason(),t.isRejected=!0),t},</span>i.prototype.all=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return arguments.length&gt;0&amp;&amp;this._warn(".all() was passed arguments but it does not take any"),new E(this).promise()},</span>i.prototype.error=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this.caught(f.originatesFromRejection,t)},</span>i.getNewLibraryCopy=e.exports,i.is=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t instanceof i},</span>i.fromNode=i.fromCallback=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >new i(b);<span class="cstat-no" title="statement not covered" >e._captureStackTrace();v</span>ar n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;!!Object(arguments[1]).multiArgs,r=<span class="cstat-no" title="statement not covered" >O(t)(R(e,n));<span class="cstat-no" title="statement not covered" >return r===S&amp;&amp;e._rejectCallback(r.e,!0),e._isFateSealed()||e._setAsyncGuaranteed(),e},</span>i.all=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return new E(t).promise()},</span>i.cast=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >j(t);<span class="cstat-no" title="statement not covered" >return e instanceof i||(e=new i(b),e._captureStackTrace(),e._setFulfilled(),e._rejectionHandler0=t),e},</span>i.resolve=i.fulfilled=i.cast,i.reject=i.rejected=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >new i(b);<span class="cstat-no" title="statement not covered" >return e._captureStackTrace(),e._rejectCallback(t,!0),e},</span>i.setScheduler=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new m("expecting a function but got "+f.classString(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn v.setScheduler(t)},</span>i.prototype._then=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,r,o){var s=<span class="cstat-no" title="statement not covered" >void 0!==o,a=<span class="cstat-no" title="statement not covered" >s?o:new i(b),l=<span class="cstat-no" title="statement not covered" >this._target(),u=<span class="cstat-no" title="statement not covered" >l._bitField;<span class="cstat-no" title="statement not covered" >s||(a._propagateFrom(this,3),a._captureStackTrace(),void 0===r&amp;&amp;0!==(2097152&amp;this._bitField)&amp;&amp;(r=0!==(50397184&amp;u)?this._boundValue():l===this?void 0:this._boundTo),this._fireEvent("promiseChained",this,a));v</span>ar p=<span class="cstat-no" title="statement not covered" >c();<span class="cstat-no" title="statement not covered" >if(0!==(50397184&amp;u)){var h,_,d=<span class="cstat-no" title="statement not covered" >l._settlePromiseCtx;<span class="cstat-no" title="statement not covered" >0!==(33554432&amp;u)?(_=l._rejectionHandler0,h=t):0!==(16777216&amp;u)?(_=l._fulfillmentHandler0,h=e,l._unsetRejectionIsUnhandled()):(d=l._settlePromiseLateCancellationObserver,_=new g("late cancellation observer"),l._attachExtraTrace(_),h=e),v.invoke(d,l,{handler:null===p?h:"function"==typeof h&amp;&amp;f.domainBind(p,h),promise:a,receiver:r,value:_})}e</span>lse <span class="cstat-no" title="statement not covered" >l._addCallbacks(t,e,a,r,p);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a},</span>i.prototype._length=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 65535&amp;this._bitField},</span>i.prototype._isFateSealed=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(117506048&amp;this._bitField)},</span>i.prototype._isFollowing=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 67108864===(67108864&amp;this._bitField)},</span>i.prototype._setLength=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._bitField=-65536&amp;this._bitField|65535&amp;t},</span>i.prototype._setFulfilled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=33554432|this._bitField,this._fireEvent("promiseFulfilled",this)},</span>i.prototype._setRejected=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=16777216|this._bitField,this._fireEvent("promiseRejected",this)},</span>i.prototype._setFollowing=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=67108864|this._bitField,this._fireEvent("promiseResolved",this)},</span>i.prototype._setIsFinal=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=4194304|this._bitField},</span>i.prototype._isFinal=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return(4194304&amp;this._bitField)&gt;0},</span>i.prototype._unsetCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=-65537&amp;this._bitField},</span>i.prototype._setCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=65536|this._bitField,this._fireEvent("promiseCancelled",this)},</span>i.prototype._setWillBeCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=8388608|this._bitField},</span>i.prototype._setAsyncGuaranteed=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >v.hasCustomScheduler()||(this._bitField=134217728|this._bitField)},</span>i.prototype._receiverAt=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >0===t?this._receiver0:this[4*t-4+3];<span class="cstat-no" title="statement not covered" >return e===h?void 0:void 0===e&amp;&amp;this._isBound()?this._boundValue():e},</span>i.prototype._promiseAt=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this[4*t-4+2]},</span>i.prototype._fulfillmentHandlerAt=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this[4*t-4+0]},</span>i.prototype._rejectionHandlerAt=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this[4*t-4+1]},</span>i.prototype._boundValue=<span class="fstat-no" title="function not covered" >function()</span>{},i.prototype._migrateCallback0=<span class="fstat-no" title="function not covered" >function(</span>t){var e=(<span class="cstat-no" title="statement not covered" >t._bitField,t._fulfillmentHandler0),n=<span class="cstat-no" title="statement not covered" >t._rejectionHandler0,r=<span class="cstat-no" title="statement not covered" >t._promise0,i=<span class="cstat-no" title="statement not covered" >t._receiverAt(0);<span class="cstat-no" title="statement not covered" >void 0===i&amp;&amp;(i=h),this._addCallbacks(e,n,r,i,null)},</span>i.prototype._migrateCallbackAt=<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t._fulfillmentHandlerAt(e),r=<span class="cstat-no" title="statement not covered" >t._rejectionHandlerAt(e),i=<span class="cstat-no" title="statement not covered" >t._promiseAt(e),o=<span class="cstat-no" title="statement not covered" >t._receiverAt(e);<span class="cstat-no" title="statement not covered" >void 0===o&amp;&amp;(o=h),this._addCallbacks(n,r,i,o,null)},</span>i.prototype._addCallbacks=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,r,i){var o=<span class="cstat-no" title="statement not covered" >this._length();<span class="cstat-no" title="statement not covered" >if(o&gt;=65531&amp;&amp;(o=0,this._setLength(0)),0===o)<span class="cstat-no" title="statement not covered" >this._promise0=n,this._receiver0=r,"function"==typeof t&amp;&amp;(this._fulfillmentHandler0=null===i?t:f.domainBind(i,t)),"function"==typeof e&amp;&amp;(this._rejectionHandler0=null===i?e:f.domainBind(i,e));else{var s=<span class="cstat-no" title="statement not covered" >4*o-4;<span class="cstat-no" title="statement not covered" >this[s+2]=n,this[s+3]=r,"function"==typeof t&amp;&amp;(this[s+0]=null===i?t:f.domainBind(i,t)),"function"==typeof e&amp;&amp;(this[s+1]=null===i?e:f.domainBind(i,e))}<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._setLength(o+1),o},</span>i.prototype._proxy=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >this._addCallbacks(void 0,void 0,e,t,null)},</span>i.prototype._resolveCallback=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if(0===(117506048&amp;this._bitField)){<span class="cstat-no" title="statement not covered" >if(t===this)<span class="cstat-no" title="statement not covered" >return this._rejectCallback(l(),!1);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >j(t,this);<span class="cstat-no" title="statement not covered" >if(!(n instanceof i))<span class="cstat-no" title="statement not covered" >return this._fulfill(t);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;this._propagateFrom(n,2);v</span>ar r=<span class="cstat-no" title="statement not covered" >n._target();<span class="cstat-no" title="statement not covered" >if(r===this)<span class="cstat-no" title="statement not covered" >return void this._reject(l());v</span></span>ar o=<span class="cstat-no" title="statement not covered" >r._bitField;<span class="cstat-no" title="statement not covered" >if(0===(50397184&amp;o)){var s=<span class="cstat-no" title="statement not covered" >this._length();<span class="cstat-no" title="statement not covered" >s&gt;0&amp;&amp;r._migrateCallback0(this);<span class="cstat-no" title="statement not covered" >f</span>or(var a=1;s&gt;a;++a)<span class="cstat-no" title="statement not covered" >r._migrateCallbackAt(this,a);<span class="cstat-no" title="statement not covered" >t</span></span>his._setFollowing(),this._setLength(0),this._setFollowee(r)}e</span>lse <span class="cstat-no" title="statement not covered" >if(0!==(33554432&amp;o))<span class="cstat-no" title="statement not covered" >this._fulfill(r._value());else <span class="cstat-no" title="statement not covered" >if(0!==(16777216&amp;o))<span class="cstat-no" title="statement not covered" >this._reject(r._reason());else{var c=<span class="cstat-no" title="statement not covered" >new g("late cancellation observer");<span class="cstat-no" title="statement not covered" >r._attachExtraTrace(c),this._reject(c)}}</span>}</span></span></span>,</span>i.prototype._rejectCallback=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >f.ensureErrorObject(t),i=<span class="cstat-no" title="statement not covered" >r===t;<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;!n&amp;&amp;x.warnings()){var o=<span class="cstat-no" title="statement not covered" >"a promise was rejected with a non-error: "+f.classString(t);<span class="cstat-no" title="statement not covered" >this._warn(o,!0)}<span class="cstat-no" title="statement not covered" >t</span></span>his._attachExtraTrace(r,!!e&amp;&amp;i),this._reject(t)},</span>i.prototype._resolveFromExecutor=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" >this._captureStackTrace(),this._pushContext();v</span>ar n=<span class="cstat-no" title="statement not covered" >!0,r=<span class="cstat-no" title="statement not covered" >this._execute(t,<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >e._resolveCallback(t)},<span class="fstat-no" title="function not covered" ></span>function(</span>t){<span class="cstat-no" title="statement not covered" >e._rejectCallback(t,n)})</span>;<span class="cstat-no" title="statement not covered" >n=!1,this._popContext(),void 0!==r&amp;&amp;e._rejectCallback(r,!0)},</span>i.prototype._settlePromiseFromHandler=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,r){var i=<span class="cstat-no" title="statement not covered" >r._bitField;<span class="cstat-no" title="statement not covered" >if(0===(65536&amp;i)){<span class="cstat-no" title="statement not covered" >r._pushContext();v</span>ar o;<span class="cstat-no" title="statement not covered" >e===w?n&amp;&amp;"number"==typeof n.length?o=O(t).apply(this._boundValue(),n):(o=S,o.e=new m("cannot .spread() a non-array: "+f.classString(n))):o=O(t).call(e,n);v</span>ar s=<span class="cstat-no" title="statement not covered" >r._popContext();<span class="cstat-no" title="statement not covered" >i=r._bitField,0===(65536&amp;i)&amp;&amp;(o===C?r._reject(n):o===S?r._rejectCallback(o.e,!1):(x.checkForgottenReturns(o,s,"",r,this),r._resolveCallback(o)))}}</span>,</span>i.prototype._target=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >for(var t=this;t._isFollowing();)<span class="cstat-no" title="statement not covered" >t=t._followee();<span class="cstat-no" title="statement not covered" >r</span></span>eturn t},</span>i.prototype._followee=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._rejectionHandler0},</span>i.prototype._setFollowee=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._rejectionHandler0=t},</span>i.prototype._settlePromise=<span class="fstat-no" title="function not covered" >function(</span>t,e,r,o){var s=<span class="cstat-no" title="statement not covered" >t instanceof i,a=<span class="cstat-no" title="statement not covered" >this._bitField,c=<span class="cstat-no" title="statement not covered" >0!==(134217728&amp;a);<span class="cstat-no" title="statement not covered" >0!==(65536&amp;a)?(s&amp;&amp;t._invokeInternalOnCancel(),r instanceof T&amp;&amp;r.isFinallyHandler()?(r.cancelPromise=t,O(e).call(r,o)===S&amp;&amp;t._reject(S.e)):e===u?t._fulfill(u.call(r)):r instanceof n?r._promiseCancelled(t):s||t instanceof E?t._cancel():r.cancel()):"function"==typeof e?s?(c&amp;&amp;t._setAsyncGuaranteed(),this._settlePromiseFromHandler(e,r,o,t)):e.call(r,o,t):r instanceof n?r._isResolved()||(0!==(33554432&amp;a)?r._promiseFulfilled(o,t):r._promiseRejected(o,t)):s&amp;&amp;(c&amp;&amp;t._setAsyncGuaranteed(),0!==(33554432&amp;a)?t._fulfill(o):t._reject(o))},</span>i.prototype._settlePromiseLateCancellationObserver=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.handler,n=<span class="cstat-no" title="statement not covered" >t.promise,r=<span class="cstat-no" title="statement not covered" >t.receiver,o=<span class="cstat-no" title="statement not covered" >t.value;<span class="cstat-no" title="statement not covered" >"function"==typeof e?n instanceof i?this._settlePromiseFromHandler(e,r,o,n):e.call(r,o,n):n instanceof i&amp;&amp;n._reject(o)},</span>i.prototype._settlePromiseCtx=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._settlePromise(t.promise,t.handler,t.receiver,t.value)},</span>i.prototype._settlePromise0=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >this._promise0,i=<span class="cstat-no" title="statement not covered" >this._receiverAt(0);<span class="cstat-no" title="statement not covered" >this._promise0=void 0,this._receiver0=void 0,this._settlePromise(r,t,i,e)},</span>i.prototype._clearCallbackDataAtIndex=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >4*t-4;<span class="cstat-no" title="statement not covered" >this[e+2]=this[e+3]=this[e+0]=this[e+1]=void 0},</span>i.prototype._fulfill=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this._bitField;<span class="cstat-no" title="statement not covered" >if(!((117506048&amp;e)&gt;&gt;&gt;16)){<span class="cstat-no" title="statement not covered" >if(t===this){var n=<span class="cstat-no" title="statement not covered" >l();<span class="cstat-no" title="statement not covered" >return this._attachExtraTrace(n),this._reject(n)}<span class="cstat-no" title="statement not covered" >t</span></span>his._setFulfilled(),this._rejectionHandler0=t,(65535&amp;e)&gt;0&amp;&amp;(0!==(134217728&amp;e)?this._settlePromises():v.settlePromises(this))}}</span>,</span>i.prototype._reject=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this._bitField;<span class="cstat-no" title="statement not covered" >if(!((117506048&amp;e)&gt;&gt;&gt;16))<span class="cstat-no" title="statement not covered" >return this._setRejected(),this._fulfillmentHandler0=t,this._isFinal()?v.fatalError(t,f.isNode):void((65535&amp;e)&gt;0?v.settlePromises(this):this._ensurePossibleRejectionHandled())},</span></span>i.prototype._fulfillPromises=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=1;t&gt;n;n++){var r=<span class="cstat-no" title="statement not covered" >this._fulfillmentHandlerAt(n),i=<span class="cstat-no" title="statement not covered" >this._promiseAt(n),o=<span class="cstat-no" title="statement not covered" >this._receiverAt(n);<span class="cstat-no" title="statement not covered" >this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}}</span>,</span>i.prototype._rejectPromises=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=1;t&gt;n;n++){var r=<span class="cstat-no" title="statement not covered" >this._rejectionHandlerAt(n),i=<span class="cstat-no" title="statement not covered" >this._promiseAt(n),o=<span class="cstat-no" title="statement not covered" >this._receiverAt(n);<span class="cstat-no" title="statement not covered" >this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}}</span>,</span>i.prototype._settlePromises=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._bitField,e=<span class="cstat-no" title="statement not covered" >65535&amp;t;<span class="cstat-no" title="statement not covered" >if(e&gt;0){<span class="cstat-no" title="statement not covered" >if(0!==(16842752&amp;t)){var n=<span class="cstat-no" title="statement not covered" >this._fulfillmentHandler0;<span class="cstat-no" title="statement not covered" >this._settlePromise0(this._rejectionHandler0,n,t),this._rejectPromises(e,n)}e</span>lse{var r=<span class="cstat-no" title="statement not covered" >this._rejectionHandler0;<span class="cstat-no" title="statement not covered" >this._settlePromise0(this._fulfillmentHandler0,r,t),this._fulfillPromises(e,r)}<span class="cstat-no" title="statement not covered" >t</span></span>his._setLength(0)}<span class="cstat-no" title="statement not covered" >t</span></span>his._clearCancellationData()},</span>i.prototype._settledValue=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._bitField;<span class="cstat-no" title="statement not covered" >return 0!==(33554432&amp;t)?this._rejectionHandler0:0!==(16777216&amp;t)?this._fulfillmentHandler0:void 0},</span>i.defer=i.pending=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >x.deprecated("Promise.defer","new Promise");v</span>ar t=<span class="cstat-no" title="statement not covered" >new i(b);<span class="cstat-no" title="statement not covered" >return{promise:t,resolve:o,reject:s}},</span>f.notEnumerableProp(i,"_makeSelfResolutionError",l),t("./method")(i,b,j,p,x),t("./bind")(i,b,j,x),t("./cancel")(i,E,p,x),t("./direct_resolve")(i),t("./synchronous_inspection")(i),t("./join")(i,E,j,b,v,c),i.Promise=i,i.version="3.4.7",t("./map.js")(i,E,p,j,b,x),t("./call_get.js")(i),t("./using.js")(i,p,j,F,b,x),t("./timers.js")(i,b,x),t("./generators.js")(i,p,b,j,n,x),t("./nodeify.js")(i),t("./promisify.js")(i,b),t("./props.js")(i,E,j,p),t("./race.js")(i,b,j,p),t("./reduce.js")(i,E,p,j,b,x),t("./settle.js")(i,E,x),t("./some.js")(i,E,p),t("./filter.js")(i,b),t("./each.js")(i,b),t("./any.js")(i),f.toFastProperties(i),f.toFastProperties(i.prototype),a({a:1}),a({b:2}),a({c:3}),a(1),a(<span class="fstat-no" title="function not covered" >function()</span>{}),a(void 0),a(!1),a(new i(b)),x.setBounds(d.firstLineError,f.lastLineError),i}}</span>,</span>{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o){function <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >switch(t){case-2:<span class="cstat-no" title="statement not covered" >return[];c</span>ase-3:<span class="cstat-no" title="statement not covered" >return{}}}f</span>unction <span class="fstat-no" title="function not covered" >a(t){var r=<span class="cstat-no" title="statement not covered" >this._promise=new e(n);<span class="cstat-no" title="statement not covered" >t instanceof e&amp;&amp;r._propagateFrom(t,3),r._setOnCancel(this),this._values=t,this._length=0,this._totalResolved=0,this._init(void 0,-2)}v</span>ar c=<span class="cstat-no" title="statement not covered" >t("./util");<span class="cstat-no" title="statement not covered" >return c.isArray,c.inherits(a,o),a.prototype.length=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._length},</span>a.prototype.promise=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._promise},</span>a.prototype._init=function <span class="fstat-no" title="function not covered" >l(t,n){var o=<span class="cstat-no" title="statement not covered" >r(this._values,this._promise);<span class="cstat-no" title="statement not covered" >if(o instanceof e){<span class="cstat-no" title="statement not covered" >o=o._target();v</span>ar a=<span class="cstat-no" title="statement not covered" >o._bitField;<span class="cstat-no" title="statement not covered" >if(this._values=o,0===(50397184&amp;a))<span class="cstat-no" title="statement not covered" >return this._promise._setAsyncGuaranteed(),o._then(l,this._reject,void 0,this,n);<span class="cstat-no" title="statement not covered" >i</span></span>f(0===(33554432&amp;a))<span class="cstat-no" title="statement not covered" >return 0!==(16777216&amp;a)?this._reject(o._reason()):this._cancel();<span class="cstat-no" title="statement not covered" >o</span></span>=o._value()}<span class="cstat-no" title="statement not covered" >i</span></span>f(o=c.asArray(o),null===o){var u=<span class="cstat-no" title="statement not covered" >i("expecting an array or an iterable object but got "+c.classString(o)).reason();<span class="cstat-no" title="statement not covered" >return void this._promise._rejectCallback(u,!1)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0===o.length?void(-5===n?this._resolveEmptyArray():this._resolve(s(n))):void this._iterate(o)},</span>a.prototype._iterate=<span class="fstat-no" title="function not covered" >function(</span>t){var n=<span class="cstat-no" title="statement not covered" >this.getActualLength(t.length);<span class="cstat-no" title="statement not covered" >this._length=n,this._values=this.shouldCopyValues()?new Array(n):this._values;<span class="cstat-no" title="statement not covered" >f</span>or(var i=this._promise,o=!1,s=null,a=0;n&gt;a;++a){var c=<span class="cstat-no" title="statement not covered" >r(t[a],i);<span class="cstat-no" title="statement not covered" >c instanceof e?(c=c._target(),s=c._bitField):s=null,o?null!==s&amp;&amp;c.suppressUnhandledRejections():null!==s?0===(50397184&amp;s)?(c._proxy(this,a),this._values[a]=c):o=0!==(33554432&amp;s)?this._promiseFulfilled(c._value(),a):0!==(16777216&amp;s)?this._promiseRejected(c._reason(),a):this._promiseCancelled(a):o=this._promiseFulfilled(c,a)}<span class="cstat-no" title="statement not covered" >o</span></span>||i._setAsyncGuaranteed()},</span>a.prototype._isResolved=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return null===this._values},</span>a.prototype._resolve=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._values=null,this._promise._fulfill(t)},</span>a.prototype._cancel=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >!this._isResolved()&amp;&amp;this._promise._isCancellable()&amp;&amp;(this._values=null,this._promise._cancel())},</span>a.prototype._reject=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._values=null,this._promise._rejectCallback(t,!1)},</span>a.prototype._promiseFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >this._values[e]=t;v</span>ar n=<span class="cstat-no" title="statement not covered" >++this._totalResolved;<span class="cstat-no" title="statement not covered" >return n&gt;=this._length&amp;&amp;(this._resolve(this._values),!0)},</span>a.prototype._promiseCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._cancel(),!0},</span>a.prototype._promiseRejected=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._totalResolved++,this._reject(t),!0},</span>a.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(!this._isResolved()){var t=<span class="cstat-no" title="statement not covered" >this._values;<span class="cstat-no" title="statement not covered" >if(this._cancel(),t instanceof e)<span class="cstat-no" title="statement not covered" >t.cancel();else <span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >t[n]instanceof e&amp;&amp;t[n].cancel()}}</span></span></span>,</span>a.prototype.shouldCopyValues=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return!0},</span>a.prototype.getActualLength=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t},</span>a}}</span>,</span>{"./util":36}],24:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n){function <span class="fstat-no" title="function not covered" >r(t){<span class="cstat-no" title="statement not covered" >return!C.test(t)}f</span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return t.__isPromisified__===!0}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return!1}}</span>f</span>unction <span class="fstat-no" title="function not covered" >o(t,e,n){var r=<span class="cstat-no" title="statement not covered" >f.getDataPropertyOrDefault(t,e+n,b);<span class="cstat-no" title="statement not covered" >return!!r&amp;&amp;i(r)}f</span>unction <span class="fstat-no" title="function not covered" >s(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=0;r&lt;t.length;r+=2){var i=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" >if(n.test(i))<span class="cstat-no" title="statement not covered" >for(var o=i.replace(n,""),s=0;s&lt;t.length;s+=2)<span class="cstat-no" title="statement not covered" >if(t[s]===o)<span class="cstat-no" title="statement not covered" >throw new m("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s",e))}}</span></span></span></span>f</span>unction <span class="fstat-no" title="function not covered" >a(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var a=f.inheritedDataKeys(t),c=[],l=0;l&lt;a.length;++l){var u=<span class="cstat-no" title="statement not covered" >a[l],p=<span class="cstat-no" title="statement not covered" >t[u],h=<span class="cstat-no" title="statement not covered" >r===j||j(u,p,t);<span class="cstat-no" title="statement not covered" >"function"!=typeof p||i(p)||o(t,u,e)||!r(u,p,t,h)||c.push(u,p)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn s(c,e,n),c}f</span>unction <span class="fstat-no" title="function not covered" >c(t,r,i,o,s,a){function <span class="fstat-no" title="function not covered" >c(){var i=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >r===h&amp;&amp;(i=this);v</span>ar o=<span class="cstat-no" title="statement not covered" >new e(n);<span class="cstat-no" title="statement not covered" >o._captureStackTrace();v</span>ar s=<span class="cstat-no" title="statement not covered" >"string"==typeof u&amp;&amp;this!==l?this[u]:t,c=<span class="cstat-no" title="statement not covered" >_(o,a);<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >s.apply(i,d(arguments,c))}c</span>atch(p){<span class="cstat-no" title="statement not covered" >o._rejectCallback(v(p),!0,!0)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn o._isFateSealed()||o._setAsyncGuaranteed(),o}v</span>ar l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this}(</span>),u=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >return"string"==typeof u&amp;&amp;(t=o),f.notEnumerableProp(c,"__isPromisified__",!0),c}f</span>unction <span class="fstat-no" title="function not covered" >l(t,e,n,r,i){<span class="cstat-no" title="statement not covered" >for(var o=new RegExp(E(e)+"$"),s=a(t,e,o,n),c=0,l=s.length;l&gt;c;c+=2){var u=<span class="cstat-no" title="statement not covered" >s[c],p=<span class="cstat-no" title="statement not covered" >s[c+1],_=<span class="cstat-no" title="statement not covered" >u+e;<span class="cstat-no" title="statement not covered" >if(r===k)<span class="cstat-no" title="statement not covered" >t[_]=k(u,h,u,p,e,i);else{var d=<span class="cstat-no" title="statement not covered" >r(p,<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return k(u,h,u,p,e,i)})</span>;<span class="cstat-no" title="statement not covered" >f.notEnumerableProp(d,"__isPromisified__",!0),t[_]=d}}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn f.toFastProperties(t),t}f</span>unction <span class="fstat-no" title="function not covered" >u(t,e,n){<span class="cstat-no" title="statement not covered" >return k(t,e,void 0,t,null,n)}v</span>ar p,h=<span class="cstat-no" title="statement not covered" >{},f=<span class="cstat-no" title="statement not covered" >t("./util"),_=<span class="cstat-no" title="statement not covered" >t("./nodeback"),d=<span class="cstat-no" title="statement not covered" >f.withAppended,v=<span class="cstat-no" title="statement not covered" >f.maybeWrapAsError,y=<span class="cstat-no" title="statement not covered" >f.canEvaluate,m=<span class="cstat-no" title="statement not covered" >t("./errors").TypeError,g=<span class="cstat-no" title="statement not covered" >"Async",b=<span class="cstat-no" title="statement not covered" >{__isPromisified__:!0},w=<span class="cstat-no" title="statement not covered" >["arity","length","name","arguments","caller","callee","prototype","__isPromisified__"],C=<span class="cstat-no" title="statement not covered" >new RegExp("^(?:"+w.join("|")+")$"),j=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return f.isIdentifier(t)&amp;&amp;"_"!==t.charAt(0)&amp;&amp;"constructor"!==t},</span>E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t.replace(/([$])/,"\\$")},</span>k=<span class="cstat-no" title="statement not covered" >y?p:c;<span class="cstat-no" title="statement not covered" >e.promisify=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new m("expecting a function but got "+f.classString(t));<span class="cstat-no" title="statement not covered" >i</span></span>f(i(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >e</span></span>=Object(e);v</span>ar n=<span class="cstat-no" title="statement not covered" >void 0===e.context?h:e.context,o=<span class="cstat-no" title="statement not covered" >!!e.multiArgs,s=<span class="cstat-no" title="statement not covered" >u(t,n,o);<span class="cstat-no" title="statement not covered" >return f.copyDescriptors(t,s,r),s},</span>e.promisifyAll=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t&amp;&amp;"object"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new m("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");<span class="cstat-no" title="statement not covered" >e</span></span>=Object(e);v</span>ar n=<span class="cstat-no" title="statement not covered" >!!e.multiArgs,r=<span class="cstat-no" title="statement not covered" >e.suffix;<span class="cstat-no" title="statement not covered" >"string"!=typeof r&amp;&amp;(r=g);v</span>ar i=<span class="cstat-no" title="statement not covered" >e.filter;<span class="cstat-no" title="statement not covered" >"function"!=typeof i&amp;&amp;(i=j);v</span>ar o=<span class="cstat-no" title="statement not covered" >e.promisifier;<span class="cstat-no" title="statement not covered" >if("function"!=typeof o&amp;&amp;(o=k),!f.isIdentifier(r))<span class="cstat-no" title="statement not covered" >throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=f.inheritedDataKeys(t),a=0;a&lt;s.length;++a){var c=<span class="cstat-no" title="statement not covered" >t[s[a]];<span class="cstat-no" title="statement not covered" >"constructor"!==s[a]&amp;&amp;f.isClass(c)&amp;&amp;(l(c.prototype,r,i,o,n),l(c,r,i,o,n))}<span class="cstat-no" title="statement not covered" >r</span></span>eturn l(t,r,i,o,n)}}</span>}</span>,</span>{"./errors":12,"./nodeback":20,"./util":36}],25:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i){function <span class="fstat-no" title="function not covered" >o(t){var e,n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >if(void 0!==a&amp;&amp;t instanceof a)<span class="cstat-no" title="statement not covered" >e=p(t),n=!0;else{var r=<span class="cstat-no" title="statement not covered" >u.keys(t),i=<span class="cstat-no" title="statement not covered" >r.length;<span class="cstat-no" title="statement not covered" >e=new Array(2*i);<span class="cstat-no" title="statement not covered" >f</span>or(var o=0;i&gt;o;++o){var s=<span class="cstat-no" title="statement not covered" >r[o];<span class="cstat-no" title="statement not covered" >e[o]=t[s],e[o+i]=s}}<span class="cstat-no" title="statement not covered" ></span>t</span></span>his.constructor$(e),this._isMap=n,this._init$(void 0,-3)}f</span>unction <span class="fstat-no" title="function not covered" >s(t){var n,s=<span class="cstat-no" title="statement not covered" >r(t);<span class="cstat-no" title="statement not covered" >return l(s)?(n=s instanceof e?s._then(e.props,void 0,void 0,void 0,void 0):new o(s).promise(),s instanceof e&amp;&amp;n._propagateFrom(s,2),n):i("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n")}v</span>ar a,c=<span class="cstat-no" title="statement not covered" >t("./util"),l=<span class="cstat-no" title="statement not covered" >c.isObject,u=<span class="cstat-no" title="statement not covered" >t("./es5");<span class="cstat-no" title="statement not covered" >"function"==typeof Map&amp;&amp;(a=Map);v</span>ar p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{function <span class="fstat-no" title="function not covered" >t(t,r){<span class="cstat-no" title="statement not covered" >this[e]=t,this[e+n]=r,e++}v</span>ar e=<span class="cstat-no" title="statement not covered" >0,n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(</span>r){<span class="cstat-no" title="statement not covered" >n=r.size,e=0;v</span>ar i=<span class="cstat-no" title="statement not covered" >new Array(2*r.size);<span class="cstat-no" title="statement not covered" >return r.forEach(t,i),i}}</span>(</span>),h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=new a,n=t.length/2|0,r=0;n&gt;r;++r){var i=<span class="cstat-no" title="statement not covered" >t[n+r],o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" >e.set(i,o)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn e};<span class="cstat-no" title="statement not covered" ></span>c.inherits(o,n),o.prototype._init=<span class="fstat-no" title="function not covered" >function()</span>{},o.prototype._promiseFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >this._values[e]=t;v</span>ar n=<span class="cstat-no" title="statement not covered" >++this._totalResolved;<span class="cstat-no" title="statement not covered" >if(n&gt;=this._length){var r;<span class="cstat-no" title="statement not covered" >if(this._isMap)<span class="cstat-no" title="statement not covered" >r=h(this._values);else{<span class="cstat-no" title="statement not covered" >r={};<span class="cstat-no" title="statement not covered" >f</span>or(var i=this.length(),o=0,s=this.length();s&gt;o;++o)<span class="cstat-no" title="statement not covered" >r[this._values[o+i]]=this._values[o]}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this._resolve(r),!0}<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1},</span>o.prototype.shouldCopyValues=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return!1},</span>o.prototype.getActualLength=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t&gt;&gt;1},</span>e.prototype.props=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return s(this)},</span>e.props=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return s(t)}}</span>}</span>,</span>{"./es5":13,"./util":36}],26:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";function <span class="fstat-no" title="function not covered" >r(t,e,n,r,i){<span class="cstat-no" title="statement not covered" >for(var o=0;i&gt;o;++o)<span class="cstat-no" title="statement not covered" >n[o+r]=t[o+e],t[o+e]=void 0}f</span></span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >this._capacity=t,this._length=0,this._front=0}<span class="cstat-no" title="statement not covered" >i</span>.prototype._willBeOverCapacity=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._capacity&lt;t},</span>i.prototype._pushOne=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this.length();<span class="cstat-no" title="statement not covered" >this._checkCapacity(e+1);v</span>ar n=<span class="cstat-no" title="statement not covered" >this._front+e&amp;this._capacity-1;<span class="cstat-no" title="statement not covered" >this[n]=t,this._length=e+1},</span>i.prototype.push=<span class="fstat-no" title="function not covered" >function(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.length()+3;<span class="cstat-no" title="statement not covered" >if(this._willBeOverCapacity(r))<span class="cstat-no" title="statement not covered" >return this._pushOne(t),this._pushOne(e),void this._pushOne(n);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this._front+r-3;<span class="cstat-no" title="statement not covered" >this._checkCapacity(r);v</span>ar o=<span class="cstat-no" title="statement not covered" >this._capacity-1;<span class="cstat-no" title="statement not covered" >this[i+0&amp;o]=t,this[i+1&amp;o]=e,this[i+2&amp;o]=n,this._length=r},</span>i.prototype.shift=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._front,e=<span class="cstat-no" title="statement not covered" >this[t];<span class="cstat-no" title="statement not covered" >return this[t]=void 0,this._front=t+1&amp;this._capacity-1,this._length--,e},</span>i.prototype.length=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._length},</span>i.prototype._checkCapacity=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._capacity&lt;t&amp;&amp;this._resizeTo(this._capacity&lt;&lt;1)},</span>i.prototype._resizeTo=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this._capacity;<span class="cstat-no" title="statement not covered" >this._capacity=t;v</span>ar n=<span class="cstat-no" title="statement not covered" >this._front,i=<span class="cstat-no" title="statement not covered" >this._length,o=<span class="cstat-no" title="statement not covered" >n+i&amp;e-1;<span class="cstat-no" title="statement not covered" >r(this,0,this,e,o)},</span>e.exports=i},</span>{}],27:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i){function <span class="fstat-no" title="function not covered" >o(t,o){var c=<span class="cstat-no" title="statement not covered" >r(t);<span class="cstat-no" title="statement not covered" >if(c instanceof e)<span class="cstat-no" title="statement not covered" >return a(c);<span class="cstat-no" title="statement not covered" >i</span></span>f(t=s.asArray(t),null===t)<span class="cstat-no" title="statement not covered" >return i("expecting an array or an iterable object but got "+s.classString(t));v</span></span>ar l=<span class="cstat-no" title="statement not covered" >new e(n);<span class="cstat-no" title="statement not covered" >void 0!==o&amp;&amp;l._propagateFrom(o,3);<span class="cstat-no" title="statement not covered" >f</span>or(var u=l._fulfill,p=l._reject,h=0,f=t.length;f&gt;h;++h){var _=<span class="cstat-no" title="statement not covered" >t[h];<span class="cstat-no" title="statement not covered" >(void 0!==_||h in t)&amp;&amp;e.cast(_)._then(u,p,void 0,l,null)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}v</span>ar s=<span class="cstat-no" title="statement not covered" >t("./util"),a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t.then(<span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >return o(e,t)})</span>};<span class="cstat-no" title="statement not covered" ></span>e.race=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return o(t,void 0)},</span>e.prototype.race=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return o(this,void 0)}}</span>}</span>,</span>{"./util":36}],28:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o,s){function <span class="fstat-no" title="function not covered" >a(t,n,r,i){<span class="cstat-no" title="statement not covered" >this.constructor$(t);v</span>ar s=<span class="cstat-no" title="statement not covered" >h();<span class="cstat-no" title="statement not covered" >this._fn=null===s?n:f.domainBind(s,n),void 0!==r&amp;&amp;(r=e.resolve(r),r._attachCancellationCallback(this)),this._initialValue=r,this._currentCancellable=null,i===o?this._eachValues=Array(this._length):0===i?this._eachValues=null:this._eachValues=void 0,this._promise._captureStackTrace(),this._init$(void 0,-5)}f</span>unction <span class="fstat-no" title="function not covered" >c(t,e){<span class="cstat-no" title="statement not covered" >this.isFulfilled()?e._resolve(t):e._reject(t)}f</span>unction <span class="fstat-no" title="function not covered" >l(t,e,n,i){<span class="cstat-no" title="statement not covered" >if("function"!=typeof e)<span class="cstat-no" title="statement not covered" >return r("expecting a function but got "+f.classString(e));v</span></span>ar o=<span class="cstat-no" title="statement not covered" >new a(t,e,n,i);<span class="cstat-no" title="statement not covered" >return o.promise()}f</span>unction <span class="fstat-no" title="function not covered" >u(t){<span class="cstat-no" title="statement not covered" >this.accum=t,this.array._gotAccum(t);v</span>ar n=<span class="cstat-no" title="statement not covered" >i(this.value,this.array._promise);<span class="cstat-no" title="statement not covered" >return n instanceof e?(this.array._currentCancellable=n,n._then(p,void 0,void 0,this,void 0)):p.call(this,n)}f</span>unction <span class="fstat-no" title="function not covered" >p(t){var n=<span class="cstat-no" title="statement not covered" >this.array,r=<span class="cstat-no" title="statement not covered" >n._promise,i=<span class="cstat-no" title="statement not covered" >_(n._fn);<span class="cstat-no" title="statement not covered" >r._pushContext();v</span>ar o;<span class="cstat-no" title="statement not covered" >o=void 0!==n._eachValues?i.call(r._boundValue(),t,this.index,this.length):i.call(r._boundValue(),this.accum,t,this.index,this.length),o instanceof e&amp;&amp;(n._currentCancellable=o);v</span>ar a=<span class="cstat-no" title="statement not covered" >r._popContext();<span class="cstat-no" title="statement not covered" >return s.checkForgottenReturns(o,a,void 0!==n._eachValues?"Promise.each":"Promise.reduce",r),o}v</span>ar h=<span class="cstat-no" title="statement not covered" >e._getDomain,f=<span class="cstat-no" title="statement not covered" >t("./util"),_=<span class="cstat-no" title="statement not covered" >f.tryCatch;<span class="cstat-no" title="statement not covered" >f.inherits(a,n),a.prototype._gotAccum=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >void 0!==this._eachValues&amp;&amp;null!==this._eachValues&amp;&amp;t!==o&amp;&amp;this._eachValues.push(t)},</span>a.prototype._eachComplete=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return null!==this._eachValues&amp;&amp;this._eachValues.push(t),this._eachValues},</span>a.prototype._init=<span class="fstat-no" title="function not covered" >function()</span>{},a.prototype._resolveEmptyArray=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._resolve(void 0!==this._eachValues?this._eachValues:this._initialValue)},</span>a.prototype.shouldCopyValues=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return!1},</span>a.prototype._resolve=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._promise._resolveCallback(t),this._values=null},</span>a.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return t===this._initialValue?this._cancel():void(this._isResolved()||(this._resultCancelled$(),this._currentCancellable instanceof e&amp;&amp;this._currentCancellable.cancel(),this._initialValue instanceof e&amp;&amp;this._initialValue.cancel()))},</span>a.prototype._iterate=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._values=t;v</span>ar n,r,i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" >if(void 0!==this._initialValue?(n=this._initialValue,r=0):(n=e.resolve(t[0]),r=1),this._currentCancellable=n,!n.isRejected())<span class="cstat-no" title="statement not covered" >for(;i&gt;r;++r){var o=<span class="cstat-no" title="statement not covered" >{accum:null,value:t[r],index:r,length:i,array:this};<span class="cstat-no" title="statement not covered" >n=n._then(u,void 0,void 0,o,void 0)}<span class="cstat-no" title="statement not covered" >v</span></span></span>oid 0!==this._eachValues&amp;&amp;(n=n._then(this._eachComplete,void 0,void 0,this,void 0)),n._then(c,c,void 0,n,this)},</span>e.prototype.reduce=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return l(this,t,e,null)},</span>e.reduce=<span class="fstat-no" title="function not covered" >function(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >return l(t,e,n,r)}}</span>}</span>,</span>{"./util":36}],29:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";var r,i=<span class="cstat-no" title="statement not covered" >t("./util"),o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")},</span>s=<span class="cstat-no" title="statement not covered" >i.getNativePromise();<span class="cstat-no" title="statement not covered" >if(i.isNode&amp;&amp;"undefined"==typeof MutationObserver){var a=<span class="cstat-no" title="statement not covered" >global.setImmediate,c=<span class="cstat-no" title="statement not covered" >process.nextTick;<span class="cstat-no" title="statement not covered" >r=i.isRecentNode?<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >a.call(global,t)}:<span class="fstat-no" title="function not covered" ></span>function(</span>t){<span class="cstat-no" title="statement not covered" >c.call(process,t)}}</span>e</span>lse <span class="cstat-no" title="statement not covered" >if("function"==typeof s&amp;&amp;"function"==typeof s.resolve){var l=<span class="cstat-no" title="statement not covered" >s.resolve();<span class="cstat-no" title="statement not covered" >r=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >l.then(t)}}</span>e</span>lse <span class="cstat-no" title="statement not covered" >r="undefined"==typeof MutationObserver||"undefined"!=typeof window&amp;&amp;window.navigator&amp;&amp;(window.navigator.standalone||window.cordova)?"undefined"!=typeof setImmediate?<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >setImmediate(t)}:</span>"undefined"!=typeof setTimeout?<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >setTimeout(t,0)}:</span>o:<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >document.createElement("div"),e=<span class="cstat-no" title="statement not covered" >{attributes:!0},n=<span class="cstat-no" title="statement not covered" >!1,r=<span class="cstat-no" title="statement not covered" >document.createElement("div"),i=<span class="cstat-no" title="statement not covered" >new MutationObserver(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >t.classList.toggle("foo"),n=!1})</span>;<span class="cstat-no" title="statement not covered" >i.observe(r,e);v</span>ar o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >n||(n=!0,r.classList.toggle("foo"))};<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(</span>n){var r=<span class="cstat-no" title="statement not covered" >new MutationObserver(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >r.disconnect(),n()})</span>;<span class="cstat-no" title="statement not covered" >r.observe(t,e),o()}}</span>(</span>);<span class="cstat-no" title="statement not covered" >e</span></span></span>.exports=r},</span>{"./util":36}],30:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r){function <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >this.constructor$(t)}v</span>ar o=<span class="cstat-no" title="statement not covered" >e.PromiseInspection,s=<span class="cstat-no" title="statement not covered" >t("./util");<span class="cstat-no" title="statement not covered" >s.inherits(i,n),i.prototype._promiseResolved=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >this._values[t]=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >++this._totalResolved;<span class="cstat-no" title="statement not covered" >return n&gt;=this._length&amp;&amp;(this._resolve(this._values),!0)},</span>i.prototype._promiseFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >new o;<span class="cstat-no" title="statement not covered" >return n._bitField=33554432,n._settledValueField=t,this._promiseResolved(e,n)},</span>i.prototype._promiseRejected=<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >new o;<span class="cstat-no" title="statement not covered" >return n._bitField=16777216,n._settledValueField=t,this._promiseResolved(e,n)},</span>e.settle=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return r.deprecated(".settle()",".reflect()"),new i(t).promise()},</span>e.prototype.settle=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return e.settle(this)}}</span>}</span>,</span>{"./util":36}],31:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r){function <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >this.constructor$(t),this._howMany=0,this._unwrap=!1,this._initialized=!1}f</span>unction <span class="fstat-no" title="function not covered" >o(t,e){<span class="cstat-no" title="statement not covered" >if((0|e)!==e||0&gt;e)<span class="cstat-no" title="statement not covered" >return r("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >new i(t),o=<span class="cstat-no" title="statement not covered" >n.promise();<span class="cstat-no" title="statement not covered" >return n.setHowMany(e),n.init(),o}v</span>ar s=<span class="cstat-no" title="statement not covered" >t("./util"),a=<span class="cstat-no" title="statement not covered" >t("./errors").RangeError,c=<span class="cstat-no" title="statement not covered" >t("./errors").AggregateError,l=<span class="cstat-no" title="statement not covered" >s.isArray,u=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >s.inherits(i,n),i.prototype._init=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(this._initialized){<span class="cstat-no" title="statement not covered" >if(0===this._howMany)<span class="cstat-no" title="statement not covered" >return void this._resolve([]);<span class="cstat-no" title="statement not covered" >t</span></span>his._init$(void 0,-5);v</span>ar t=<span class="cstat-no" title="statement not covered" >l(this._values);<span class="cstat-no" title="statement not covered" >!this._isResolved()&amp;&amp;t&amp;&amp;this._howMany&gt;this._canPossiblyFulfill()&amp;&amp;this._reject(this._getRangeError(this.length()));</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
}},i.prototype.init=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._initialized=!0,this._init()},</span>i.prototype.setUnwrap=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._unwrap=!0},</span>i.prototype.howMany=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._howMany},</span>i.prototype.setHowMany=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._howMany=t},</span>i.prototype._promiseFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._addFulfilled(t),this._fulfilled()===this.howMany()&amp;&amp;(this._values.length=this.howMany(),1===this.howMany()&amp;&amp;this._unwrap?this._resolve(this._values[0]):this._resolve(this._values),!0)},</span>i.prototype._promiseRejected=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return this._addRejected(t),this._checkOutcome()},</span>i.prototype._promiseCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._values instanceof e||null==this._values?this._cancel():(this._addRejected(u),this._checkOutcome())},</span>i.prototype._checkOutcome=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(this.howMany()&gt;this._canPossiblyFulfill()){<span class="cstat-no" title="statement not covered" >for(var t=new c,e=this.length();e&lt;this._values.length;++e)<span class="cstat-no" title="statement not covered" >this._values[e]!==u&amp;&amp;t.push(this._values[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.length&gt;0?this._reject(t):this._cancel(),!0}<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1},</span>i.prototype._fulfilled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._totalResolved},</span>i.prototype._rejected=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._values.length-this.length()},</span>i.prototype._addRejected=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._values.push(t)},</span>i.prototype._addFulfilled=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._values[this._totalResolved++]=t},</span>i.prototype._canPossiblyFulfill=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this.length()-this._rejected()},</span>i.prototype._getRangeError=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >"Input array must contain at least "+this._howMany+" items but contains only "+t+" items";<span class="cstat-no" title="statement not covered" >return new a(e)},</span>i.prototype._resolveEmptyArray=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._reject(this._getRangeError(0))},</span>e.some=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >return o(t,e)},</span>e.prototype.some=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return o(this,t)},</span>e._SomePromiseArray=i}},{"./errors":12,"./util":36}],32:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>t){function <span class="fstat-no" title="function not covered" >e(t){<span class="cstat-no" title="statement not covered" >void 0!==t?(t=t._target(),this._bitField=t._bitField,this._settledValueField=t._isFateSealed()?t._settledValue():void 0):(this._bitField=0,this._settledValueField=void 0)}<span class="cstat-no" title="statement not covered" >e</span>.prototype._settledValue=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._settledValueField};</span>v</span>ar n=<span class="cstat-no" title="statement not covered" >e.prototype.value=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(!this.isFulfilled())<span class="cstat-no" title="statement not covered" >throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._settledValue()},</span>r=<span class="cstat-no" title="statement not covered" >e.prototype.error=e.prototype.reason=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >if(!this.isRejected())<span class="cstat-no" title="statement not covered" >throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._settledValue()},</span>i=<span class="cstat-no" title="statement not covered" >e.prototype.isFulfilled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(33554432&amp;this._bitField)},</span>o=<span class="cstat-no" title="statement not covered" >e.prototype.isRejected=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(16777216&amp;this._bitField)},</span>s=<span class="cstat-no" title="statement not covered" >e.prototype.isPending=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0===(50397184&amp;this._bitField)},</span>a=<span class="cstat-no" title="statement not covered" >e.prototype.isResolved=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(50331648&amp;this._bitField)};<span class="cstat-no" title="statement not covered" ></span>e.prototype.isCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(8454144&amp;this._bitField)},</span>t.prototype.__isCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 65536===(65536&amp;this._bitField)},</span>t.prototype._isCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._target().__isCancelled()},</span>t.prototype.isCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return 0!==(8454144&amp;this._target()._bitField)},</span>t.prototype.isPending=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return s.call(this._target())},</span>t.prototype.isRejected=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return o.call(this._target())},</span>t.prototype.isFulfilled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return i.call(this._target())},</span>t.prototype.isResolved=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return a.call(this._target())},</span>t.prototype.value=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return n.call(this._target())},</span>t.prototype.reason=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >this._target();<span class="cstat-no" title="statement not covered" >return t._unsetRejectionIsUnhandled(),r.call(t)},</span>t.prototype._value=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._settledValue()},</span>t.prototype._reason=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._unsetRejectionIsUnhandled(),this._settledValue()},</span>t.PromiseInspection=e}}</span>,</span>{}],33:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n){function <span class="fstat-no" title="function not covered" >r(t,r){<span class="cstat-no" title="statement not covered" >if(u(t)){<span class="cstat-no" title="statement not covered" >if(t instanceof e)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >o(t);<span class="cstat-no" title="statement not covered" >if(i===l){<span class="cstat-no" title="statement not covered" >r&amp;&amp;r._pushContext();v</span>ar c=<span class="cstat-no" title="statement not covered" >e.reject(i.e);<span class="cstat-no" title="statement not covered" >return r&amp;&amp;r._popContext(),c}<span class="cstat-no" title="statement not covered" >i</span></span>f("function"==typeof i){<span class="cstat-no" title="statement not covered" >if(s(t)){var c=<span class="cstat-no" title="statement not covered" >new e(n);<span class="cstat-no" title="statement not covered" >return t._then(c._fulfill,c._reject,void 0,c,null),c}<span class="cstat-no" title="statement not covered" >r</span></span>eturn a(t,i,r)}}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t}f</span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >return t.then}f</span>unction <span class="fstat-no" title="function not covered" >o(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return i(t)}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return l.e=e,l}}</span>f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return p.call(t,"_promise0")}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return!1}}</span>f</span>unction <span class="fstat-no" title="function not covered" >a(t,r,i){function <span class="fstat-no" title="function not covered" >o(t){<span class="cstat-no" title="statement not covered" >a&amp;&amp;(a._resolveCallback(t),a=null)}f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >a&amp;&amp;(a._rejectCallback(t,p,!0),a=null)}v</span>ar a=<span class="cstat-no" title="statement not covered" >new e(n),u=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" >i&amp;&amp;i._pushContext(),a._captureStackTrace(),i&amp;&amp;i._popContext();v</span>ar p=<span class="cstat-no" title="statement not covered" >!0,h=<span class="cstat-no" title="statement not covered" >c.tryCatch(r).call(t,o,s);<span class="cstat-no" title="statement not covered" >return p=!1,a&amp;&amp;h===l&amp;&amp;(a._rejectCallback(h.e,!0,!0),a=null),u}v</span>ar c=<span class="cstat-no" title="statement not covered" >t("./util"),l=<span class="cstat-no" title="statement not covered" >c.errorObj,u=<span class="cstat-no" title="statement not covered" >c.isObject,p=<span class="cstat-no" title="statement not covered" >{}.hasOwnProperty;<span class="cstat-no" title="statement not covered" >return r}}</span>,</span>{"./util":36}],34:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r){function <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >this.handle=t}f</span>unction <span class="fstat-no" title="function not covered" >o(t){<span class="cstat-no" title="statement not covered" >return clearTimeout(this.handle),t}f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >throw clearTimeout(this.handle),t}v</span>ar a=<span class="cstat-no" title="statement not covered" >t("./util"),c=<span class="cstat-no" title="statement not covered" >e.TimeoutError;<span class="cstat-no" title="statement not covered" >i.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >clearTimeout(this.handle)};</span>v</span>ar l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return u(+this).thenReturn(t)},</span>u=<span class="cstat-no" title="statement not covered" >e.delay=<span class="fstat-no" title="function not covered" >function(</span>t,o){var s,a;<span class="cstat-no" title="statement not covered" >return void 0!==o?(s=e.resolve(o)._then(l,null,null,t,void 0),r.cancellation()&amp;&amp;o instanceof e&amp;&amp;s._setOnCancel(o)):(s=new e(n),a=setTimeout(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >s._fulfill()},</span>+t),r.cancellation()&amp;&amp;s._setOnCancel(new i(a)),s._captureStackTrace()),s._setAsyncGuaranteed(),s};<span class="cstat-no" title="statement not covered" ></span>e.prototype.delay=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return u(t,this)};</span>v</span>ar p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e,n){var r;<span class="cstat-no" title="statement not covered" >r="string"!=typeof e?e instanceof Error?e:new c("operation timed out"):new c(e),a.markAsOriginatingFromRejection(r),t._attachExtraTrace(r),t._reject(r),null!=n&amp;&amp;n.cancel()};<span class="cstat-no" title="statement not covered" ></span>e.prototype.timeout=<span class="fstat-no" title="function not covered" >function(</span>t,e){<span class="cstat-no" title="statement not covered" >t=+t;v</span>ar n,a,c=<span class="cstat-no" title="statement not covered" >new i(setTimeout(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >n.isPending()&amp;&amp;p(n,e,a)},</span>t));<span class="cstat-no" title="statement not covered" >return r.cancellation()?(a=this.then(),n=a._then(o,s,void 0,c,void 0),n._setOnCancel(c)):n=this._then(o,s,void 0,c,void 0),n}}</span>}</span>,</span>{"./util":36}],35:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >e.exports=<span class="fstat-no" title="function not covered" >function(</span>e,n,r,i,o,s){function <span class="fstat-no" title="function not covered" >a(t){<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >throw t},</span>0)}f</span>unction <span class="fstat-no" title="function not covered" >c(t){var e=<span class="cstat-no" title="statement not covered" >r(t);<span class="cstat-no" title="statement not covered" >return e!==t&amp;&amp;"function"==typeof t._isDisposable&amp;&amp;"function"==typeof t._getDisposer&amp;&amp;t._isDisposable()&amp;&amp;e._setDisposable(t._getDisposer()),e}f</span>unction <span class="fstat-no" title="function not covered" >l(t,n){function <span class="fstat-no" title="function not covered" >i(){<span class="cstat-no" title="statement not covered" >if(s&gt;=l)<span class="cstat-no" title="statement not covered" >return u._fulfill();v</span></span>ar o=<span class="cstat-no" title="statement not covered" >c(t[s++]);<span class="cstat-no" title="statement not covered" >if(o instanceof e&amp;&amp;o._isDisposable()){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >o=r(o._getDisposer().tryDispose(n),t.promise)}c</span>atch(p){<span class="cstat-no" title="statement not covered" >return a(p)}<span class="cstat-no" title="statement not covered" >i</span></span>f(o instanceof e)<span class="cstat-no" title="statement not covered" >return o._then(i,a,null,null,null)}<span class="cstat-no" title="statement not covered" >i</span></span></span>()}v</span>ar s=<span class="cstat-no" title="statement not covered" >0,l=<span class="cstat-no" title="statement not covered" >t.length,u=<span class="cstat-no" title="statement not covered" >new e(o);<span class="cstat-no" title="statement not covered" >return i(),u}f</span>unction <span class="fstat-no" title="function not covered" >u(t,e,n){<span class="cstat-no" title="statement not covered" >this._data=t,this._promise=e,this._context=n}f</span>unction <span class="fstat-no" title="function not covered" >p(t,e,n){<span class="cstat-no" title="statement not covered" >this.constructor$(t,e,n)}f</span>unction <span class="fstat-no" title="function not covered" >h(t){<span class="cstat-no" title="statement not covered" >return u.isDisposer(t)?(this.resources[this.index]._setDisposable(t),t.promise()):t}f</span>unction <span class="fstat-no" title="function not covered" >f(t){<span class="cstat-no" title="statement not covered" >this.length=t,this.promise=null,this[t-1]=null}v</span>ar _=<span class="cstat-no" title="statement not covered" >t("./util"),d=<span class="cstat-no" title="statement not covered" >t("./errors").TypeError,v=<span class="cstat-no" title="statement not covered" >t("./util").inherits,y=<span class="cstat-no" title="statement not covered" >_.errorObj,m=<span class="cstat-no" title="statement not covered" >_.tryCatch,g=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >u.prototype.data=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._data},</span>u.prototype.promise=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._promise},</span>u.prototype.resource=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this.promise().isFulfilled()?this.promise().value():g},</span>u.prototype.tryDispose=<span class="fstat-no" title="function not covered" >function(</span>t){var e=<span class="cstat-no" title="statement not covered" >this.resource(),n=<span class="cstat-no" title="statement not covered" >this._context;<span class="cstat-no" title="statement not covered" >void 0!==n&amp;&amp;n._pushContext();v</span>ar r=<span class="cstat-no" title="statement not covered" >e!==g?this.doDispose(e,t):null;<span class="cstat-no" title="statement not covered" >return void 0!==n&amp;&amp;n._popContext(),this._promise._unsetDisposable(),this._data=null,r},</span>u.isDisposer=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return null!=t&amp;&amp;"function"==typeof t.resource&amp;&amp;"function"==typeof t.tryDispose},</span>v(p,u),p.prototype.doDispose=<span class="fstat-no" title="function not covered" >function(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >this.data();<span class="cstat-no" title="statement not covered" >return n.call(t,t,e)},</span>f.prototype._resultCancelled=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >for(var t=this.length,n=0;t&gt;n;++n){var r=<span class="cstat-no" title="statement not covered" >this[n];<span class="cstat-no" title="statement not covered" >r instanceof e&amp;&amp;r.cancel()}}</span>,</span>e.using=<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" >if(2&gt;t)<span class="cstat-no" title="statement not covered" >return n("you must pass at least 2 arguments to Promise.using");v</span></span>ar i=<span class="cstat-no" title="statement not covered" >arguments[t-1];<span class="cstat-no" title="statement not covered" >if("function"!=typeof i)<span class="cstat-no" title="statement not covered" >return n("expecting a function but got "+_.classString(i));v</span></span>ar o,a=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" >2===t&amp;&amp;Array.isArray(arguments[0])?(o=arguments[0],t=o.length,a=!1):(o=arguments,t--);<span class="cstat-no" title="statement not covered" >f</span>or(var c=new f(t),p=0;t&gt;p;++p){var d=<span class="cstat-no" title="statement not covered" >o[p];<span class="cstat-no" title="statement not covered" >if(u.isDisposer(d)){var v=<span class="cstat-no" title="statement not covered" >d;<span class="cstat-no" title="statement not covered" >d=d.promise(),d._setDisposable(v)}e</span>lse{var g=<span class="cstat-no" title="statement not covered" >r(d);<span class="cstat-no" title="statement not covered" >g instanceof e&amp;&amp;(d=g._then(h,null,null,{resources:c,index:p},void 0))}<span class="cstat-no" title="statement not covered" >c</span></span>[p]=d}<span class="cstat-no" title="statement not covered" >f</span></span>or(var b=new Array(c.length),p=0;p&lt;b.length;++p)<span class="cstat-no" title="statement not covered" >b[p]=e.resolve(c[p]).reflect();v</span></span>ar w=<span class="cstat-no" title="statement not covered" >e.all(b).then(<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=0;e&lt;t.length;++e){var n=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" >if(n.isRejected())<span class="cstat-no" title="statement not covered" >return y.e=n.error(),y;<span class="cstat-no" title="statement not covered" >i</span></span>f(!n.isFulfilled())<span class="cstat-no" title="statement not covered" >return void w.cancel();<span class="cstat-no" title="statement not covered" >t</span></span>[e]=n.value()}<span class="cstat-no" title="statement not covered" >C</span></span>._pushContext(),i=m(i);v</span>ar r=<span class="cstat-no" title="statement not covered" >a?i.apply(void 0,t):i(t),o=<span class="cstat-no" title="statement not covered" >C._popContext();<span class="cstat-no" title="statement not covered" >return s.checkForgottenReturns(r,o,"Promise.using",C),r})</span>,C=<span class="cstat-no" title="statement not covered" >w.lastly(<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >new e.PromiseInspection(w);<span class="cstat-no" title="statement not covered" >return l(c,t)})</span>;<span class="cstat-no" title="statement not covered" >return c.promise=C,C._setOnCancel(c),C},</span>e.prototype._setDisposable=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >this._bitField=131072|this._bitField,this._disposer=t},</span>e.prototype._isDisposable=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return(131072&amp;this._bitField)&gt;0},</span>e.prototype._getDisposer=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return this._disposer},</span>e.prototype._unsetDisposable=<span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >this._bitField=-131073&amp;this._bitField,this._disposer=void 0},</span>e.prototype.disposer=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >if("function"==typeof t)<span class="cstat-no" title="statement not covered" >return new p(t,this,i());<span class="cstat-no" title="statement not covered" >t</span></span>hrow new d}}</span>}</span>,</span>{"./errors":12,"./util":36}],36:[<span class="fstat-no" title="function not covered" >function(</span>t,e,n){"use strict";function <span class="fstat-no" title="function not covered" >r(){<span class="cstat-no" title="statement not covered" >try{var t=<span class="cstat-no" title="statement not covered" >P;<span class="cstat-no" title="statement not covered" >return P=null,t.apply(this,arguments)}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return T.e=e,T}}</span>f</span>unction <span class="fstat-no" title="function not covered" >i(t){<span class="cstat-no" title="statement not covered" >return P=t,r}f</span>unction <span class="fstat-no" title="function not covered" >o(t){<span class="cstat-no" title="statement not covered" >return null==t||t===!0||t===!1||"string"==typeof t||"number"==typeof t}f</span>unction <span class="fstat-no" title="function not covered" >s(t){<span class="cstat-no" title="statement not covered" >return"function"==typeof t||"object"==typeof t&amp;&amp;null!==t}f</span>unction <span class="fstat-no" title="function not covered" >a(t){<span class="cstat-no" title="statement not covered" >return o(t)?new Error(v(t)):t}f</span>unction <span class="fstat-no" title="function not covered" >c(t,e){var n,r=<span class="cstat-no" title="statement not covered" >t.length,i=<span class="cstat-no" title="statement not covered" >new Array(r+1);<span class="cstat-no" title="statement not covered" >for(n=0;r&gt;n;++n)<span class="cstat-no" title="statement not covered" >i[n]=t[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i[n]=e,i}f</span>unction <span class="fstat-no" title="function not covered" >l(t,e,n){<span class="cstat-no" title="statement not covered" >if(!F.isES5)<span class="cstat-no" title="statement not covered" >return{}.hasOwnProperty.call(t,e)?t[e]:void 0;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(t,e);<span class="cstat-no" title="statement not covered" >return null!=r?null==r.get&amp;&amp;null==r.set?r.value:n:void 0}f</span>unction <span class="fstat-no" title="function not covered" >u(t,e,n){<span class="cstat-no" title="statement not covered" >if(o(t))<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >{value:n,configurable:!0,enumerable:!1,writable:!0};<span class="cstat-no" title="statement not covered" >return F.defineProperty(t,e,r),t}f</span>unction <span class="fstat-no" title="function not covered" >p(t){<span class="cstat-no" title="statement not covered" >throw t}f</span>unction <span class="fstat-no" title="function not covered" >h(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if("function"==typeof t){var e=<span class="cstat-no" title="statement not covered" >F.names(t.prototype),n=<span class="cstat-no" title="statement not covered" >F.isES5&amp;&amp;e.length&gt;1,r=<span class="cstat-no" title="statement not covered" >e.length&gt;0&amp;&amp;!(1===e.length&amp;&amp;"constructor"===e[0]),i=<span class="cstat-no" title="statement not covered" >A.test(t+"")&amp;&amp;F.names(t).length&gt;0;<span class="cstat-no" title="statement not covered" >if(n||r||i)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}c</span>atch(o){<span class="cstat-no" title="statement not covered" >return!1}}</span>f</span>unction <span class="fstat-no" title="function not covered" >f(t){function <span class="fstat-no" title="function not covered" >e(){}<span class="cstat-no" title="statement not covered" >e.prototype=t;<span class="cstat-no" title="statement not covered" >f</span>or(var n=8;n--;)<span class="cstat-no" title="statement not covered" >new e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}f</span>unction <span class="fstat-no" title="function not covered" >_(t){<span class="cstat-no" title="statement not covered" >return D.test(t)}f</span>unction <span class="fstat-no" title="function not covered" >d(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=new Array(t),i=0;t&gt;i;++i)<span class="cstat-no" title="statement not covered" >r[i]=e+i+n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}f</span>unction <span class="fstat-no" title="function not covered" >v(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return t+""}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return"[no string representation]"}}</span>f</span>unction <span class="fstat-no" title="function not covered" >y(t){<span class="cstat-no" title="statement not covered" >return null!==t&amp;&amp;"object"==typeof t&amp;&amp;"string"==typeof t.message&amp;&amp;"string"==typeof t.name}f</span>unction <span class="fstat-no" title="function not covered" >m(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >u(t,"isOperational",!0)}c</span>atch(e){}}f</span>unction <span class="fstat-no" title="function not covered" >g(t){<span class="cstat-no" title="statement not covered" >return null!=t&amp;&amp;(t instanceof Error.__BluebirdErrorTypes__.OperationalError||t.isOperational===!0)}f</span>unction <span class="fstat-no" title="function not covered" >b(t){<span class="cstat-no" title="statement not covered" >return y(t)&amp;&amp;F.propertyIsWritable(t,"stack")}f</span>unction <span class="fstat-no" title="function not covered" >w(t){<span class="cstat-no" title="statement not covered" >return{}.toString.call(t)}f</span>unction <span class="fstat-no" title="function not covered" >C(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=F.names(t),i=0;i&lt;r.length;++i){var o=<span class="cstat-no" title="statement not covered" >r[i];<span class="cstat-no" title="statement not covered" >if(n(o))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >F.defineProperty(e,o,F.getDescriptor(t,o))}c</span>atch(s){}}}</span></span>f</span>unction <span class="fstat-no" title="function not covered" >j(t){<span class="cstat-no" title="statement not covered" >return N?process.env[t]:void 0}f</span>unction <span class="fstat-no" title="function not covered" >E(){<span class="cstat-no" title="statement not covered" >if("function"==typeof Promise)<span class="cstat-no" title="statement not covered" >try{var t=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >function()</span>{});<span class="cstat-no" title="statement not covered" >if("[object Promise]"==={}.toString.call(t))<span class="cstat-no" title="statement not covered" >return Promise}c</span></span>atch(e){}}f</span></span>unction <span class="fstat-no" title="function not covered" >k(t,e){<span class="cstat-no" title="statement not covered" >return t.bind(e)}v</span>ar P,F=<span class="cstat-no" title="statement not covered" >t("./es5"),x=<span class="cstat-no" title="statement not covered" >"undefined"==typeof navigator,T=<span class="cstat-no" title="statement not covered" >{e:{}},R=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0!==this?this:null,S=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t,e){function <span class="fstat-no" title="function not covered" >n(){<span class="cstat-no" title="statement not covered" >this.constructor=t,this.constructor$=e;<span class="cstat-no" title="statement not covered" >f</span>or(var n in e.prototype)<span class="cstat-no" title="statement not covered" >r.call(e.prototype,n)&amp;&amp;"$"!==n.charAt(n.length-1)&amp;&amp;(this[n+"$"]=e.prototype[n])}v</span></span>ar r=<span class="cstat-no" title="statement not covered" >{}.hasOwnProperty;<span class="cstat-no" title="statement not covered" >return n.prototype=e.prototype,t.prototype=new n,t.prototype},</span>O=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >[Array.prototype,Object.prototype,Function.prototype],e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>e){<span class="cstat-no" title="statement not covered" >for(var n=0;n&lt;t.length;++n)<span class="cstat-no" title="statement not covered" >if(t[n]===e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1};<span class="cstat-no" title="statement not covered" ></span>if(F.isES5){var n=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >for(var r=[],i=Object.create(null);null!=t&amp;&amp;!e(t);){var o;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >o=n(t)}c</span>atch(s){<span class="cstat-no" title="statement not covered" >return r}<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=0;a&lt;o.length;++a){var c=<span class="cstat-no" title="statement not covered" >o[a];<span class="cstat-no" title="statement not covered" >if(!i[c]){<span class="cstat-no" title="statement not covered" >i[c]=!0;v</span>ar l=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor(t,c);<span class="cstat-no" title="statement not covered" >null!=l&amp;&amp;null==l.get&amp;&amp;null==l.set&amp;&amp;r.push(c)}}<span class="cstat-no" title="statement not covered" ></span>t</span></span>=F.getPrototypeOf(t)}<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}}</span>v</span></span>ar r=<span class="cstat-no" title="statement not covered" >{}.hasOwnProperty;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(</span>n){<span class="cstat-no" title="statement not covered" >if(e(n))<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" >t:<span class="cstat-no" title="statement not covered" >for(var o in n)<span class="cstat-no" title="statement not covered" >if(r.call(n,o))<span class="cstat-no" title="statement not covered" >i.push(o);else{<span class="cstat-no" title="statement not covered" >for(var s=0;s&lt;t.length;++s)<span class="cstat-no" title="statement not covered" >if(r.call(t[s],o))<span class="cstat-no" title="statement not covered" >continue t;<span class="cstat-no" title="statement not covered" >i</span></span></span>.push(o)}<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn i}}</span>(</span>),A=<span class="cstat-no" title="statement not covered" >/this\s*\.\s*\S+\s*=/,D=<span class="cstat-no" title="statement not covered" >/^[a-z$_][a-z$_0-9]*$/i,V=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function()</span>{<span class="cstat-no" title="statement not covered" >return"stack"in new Error?<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return b(t)?t:new Error(v(t))}:<span class="fstat-no" title="function not covered" ></span>function(</span>t){<span class="cstat-no" title="statement not covered" >if(b(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >throw new Error(v(t))}c</span>atch(e){<span class="cstat-no" title="statement not covered" >return e}}</span>}</span>(</span>),I=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return F.isArray(t)?t:null};<span class="cstat-no" title="statement not covered" ></span>if("undefined"!=typeof Symbol&amp;&amp;Symbol.iterator){var L=<span class="cstat-no" title="statement not covered" >"function"==typeof Array.from?<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return Array.from(t)}:<span class="fstat-no" title="function not covered" ></span>function(</span>t){<span class="cstat-no" title="statement not covered" >for(var e,n=[],r=t[Symbol.iterator]();!(e=r.next()).done;)<span class="cstat-no" title="statement not covered" >n.push(e.value);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n};<span class="cstat-no" title="statement not covered" ></span>I=<span class="fstat-no" title="function not covered" >function(</span>t){<span class="cstat-no" title="statement not covered" >return F.isArray(t)?t:null!=t&amp;&amp;"function"==typeof t[Symbol.iterator]?L(t):null}}</span>v</span></span>ar H=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof process&amp;&amp;"[object process]"===w(process).toLowerCase(),N=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof process&amp;&amp;"undefined"!=typeof process.env,B=<span class="cstat-no" title="statement not covered" >{isClass:h,isIdentifier:_,inheritedDataKeys:O,getDataPropertyOrDefault:l,thrower:p,isArray:F.isArray,asArray:I,notEnumerableProp:u,isPrimitive:o,isObject:s,isError:y,canEvaluate:x,errorObj:T,tryCatch:i,inherits:S,withAppended:c,maybeWrapAsError:a,toFastProperties:f,filledRange:d,toString:v,canAttachTrace:b,ensureErrorObject:V,originatesFromRejection:g,markAsOriginatingFromRejection:m,classString:w,copyDescriptors:C,hasDevTools:"undefined"!=typeof chrome&amp;&amp;chrome&amp;&amp;"function"==typeof chrome.loadTimes,isNode:H,hasEnvVariables:N,env:j,global:R,getNativePromise:E,domainBind:k};<span class="cstat-no" title="statement not covered" >B.isRecentNode=B.isNode&amp;&amp;<span class="fstat-no" title="function not covered" >function()</span>{var t=<span class="cstat-no" title="statement not covered" >process.versions.node.split(".").map(Number);<span class="cstat-no" title="statement not covered" >return 0===t[0]&amp;&amp;t[1]&gt;10||t[0]&gt;0}(</span>),B.isNode&amp;&amp;B.toFastProperties(process);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >throw new Error}c</span>atch(U){<span class="cstat-no" title="statement not covered" >B.lastLineError=U}<span class="cstat-no" title="statement not covered" >e</span></span>.exports=B},</span>{"./es5":13}]},{},[4])(4)}),"undefined"!=typeof window&amp;&amp;null!==window?window.P=window.Promise:"undefined"!=typeof self&amp;&amp;null!==self&amp;&amp;(self.P=self.Promise);</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre></td></tr>
</table></pre>
<div class='push'></div><!-- for sticky footer -->
</div><!-- /wrapper -->
<div class='footer quiet pad2 space-top1 center small'>
  Code coverage
  generated by <a href="https://istanbul.js.org/" target="_blank">istanbul</a> at Mon Dec 10 2018 09:52:44 GMT+0800 (GMT+08:00)
</div>
</div>
<script src="../../prettify.js"></script>
<script>
window.onload = function () {
        if (typeof prettyPrint === 'function') {
            prettyPrint();
        }
};
</script>
<script src="../../sorter.js"></script>
</body>
</html>
